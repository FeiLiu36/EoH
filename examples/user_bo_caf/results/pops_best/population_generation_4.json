{
     "algorithm": "Your new algorithm:\n    improvement = torch.max(mean_test_y - best_y, torch.tensor(0., dtype=torch.float64))\n    reduction = torch.max(best_y - mean_test_y, torch.tensor(0., dtype=torch.float64))\n    improvement_ratio = improvement / (torch.mean(improvement) + 1e-6)\n    reduction_ratio = reduction / (torch.mean(reduction) + 1e-6)\n    cost_effectiveness = improvement_ratio - reduction_ratio\n    budget_utilization = 1 - (budget_used / (budget_total + 1e-6))\n\n    cost_std_mean = torch.std(cost_test_y) + torch.mean(std_test_y)\n    scaled_cost = (cost_test_y - torch.min(cost_test_y)) / (torch.max(cost_test_y) - torch.min(cost_test_y))\n\n    utility_value = (cost_effectiveness * budget_utilization) / (cost_std_mean + 1e-6) - torch.mean(scaled_cost)\n    utility_value = utility_value.squeeze()\n    # ",
     "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    # {Your new algorithm:\n    improvement = torch.max(mean_test_y - best_y, torch.tensor(0., dtype=torch.float64))\n    reduction = torch.max(best_y - mean_test_y, torch.tensor(0., dtype=torch.float64))\n    improvement_ratio = improvement / (torch.mean(improvement) + 1e-6)\n    reduction_ratio = reduction / (torch.mean(reduction) + 1e-6)\n    cost_effectiveness = improvement_ratio - reduction_ratio\n    budget_utilization = 1 - (budget_used / (budget_total + 1e-6))\n\n    cost_std_mean = torch.std(cost_test_y) + torch.mean(std_test_y)\n    scaled_cost = (cost_test_y - torch.min(cost_test_y)) / (torch.max(cost_test_y) - torch.min(cost_test_y))\n\n    utility_value = (cost_effectiveness * budget_utilization) / (cost_std_mean + 1e-6) - torch.mean(scaled_cost)\n    utility_value = utility_value.squeeze()\n    # }\n    \n    return utility_value",
     "objective": 0.62248,
     "other_inf": null
}