[
     {
          "algorithm": "Your new algorithm:\n    improvement = torch.max(mean_test_y - best_y, torch.tensor(0., dtype=torch.float64))\n    reduction = torch.max(best_y - mean_test_y, torch.tensor(0., dtype=torch.float64))\n    improvement_ratio = improvement / (torch.mean(improvement) + 1e-6)\n    reduction_ratio = reduction / (torch.mean(reduction) + 1e-6)\n    cost_effectiveness = improvement_ratio - reduction_ratio\n    budget_utilization = 1 - (budget_used / (budget_total + 1e-6))\n\n    utility_value = (cost_effectiveness * budget_utilization) / (torch.std(cost_test_y) + 1e-6)\n    utility_value = utility_value.squeeze()\n    # ",
          "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    # {Your new algorithm:\n    improvement = torch.max(mean_test_y - best_y, torch.tensor(0., dtype=torch.float64))\n    reduction = torch.max(best_y - mean_test_y, torch.tensor(0., dtype=torch.float64))\n    improvement_ratio = improvement / (torch.mean(improvement) + 1e-6)\n    reduction_ratio = reduction / (torch.mean(reduction) + 1e-6)\n    cost_effectiveness = improvement_ratio - reduction_ratio\n    budget_utilization = 1 - (budget_used / (budget_total + 1e-6))\n\n    utility_value = (cost_effectiveness * budget_utilization) / (torch.std(cost_test_y) + 1e-6)\n    utility_value = utility_value.squeeze()\n    # }\n    \n    return utility_value",
          "objective": 1.12429,
          "other_inf": null
     },
     {
          "algorithm": "Your new algorithm:\n    improvement = torch.max(mean_test_y - best_y, torch.tensor(0., dtype=torch.float64))\n    reduction = torch.max(best_y - mean_test_y, torch.tensor(0., dtype=torch.float64))\n    improvement_ratio = improvement / (torch.mean(improvement) + 1e-6)\n    reduction_ratio = reduction / (torch.mean(reduction) + 1e-6)\n    cost_effectiveness = improvement_ratio - reduction_ratio\n    budget_utilization = 1 - (budget_used / (budget_total + 1e-6))\n\n    utility_value = (cost_effectiveness * budget_utilization) / (torch.std(cost_test_y) + torch.mean(std_test_y) + 1e-6) - torch.min(cost_test_y) \n    utility_value = utility_value.squeeze()\n    # ",
          "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    # {Your new algorithm:\n    improvement = torch.max(mean_test_y - best_y, torch.tensor(0., dtype=torch.float64))\n    reduction = torch.max(best_y - mean_test_y, torch.tensor(0., dtype=torch.float64))\n    improvement_ratio = improvement / (torch.mean(improvement) + 1e-6)\n    reduction_ratio = reduction / (torch.mean(reduction) + 1e-6)\n    cost_effectiveness = improvement_ratio - reduction_ratio\n    budget_utilization = 1 - (budget_used / (budget_total + 1e-6))\n\n    utility_value = (cost_effectiveness * budget_utilization) / (torch.std(cost_test_y) + torch.mean(std_test_y) + 1e-6) - torch.min(cost_test_y) \n    utility_value = utility_value.squeeze()\n    # }\n    \n    return utility_value",
          "objective": 1.93297,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm quantifies utility based on the ratio of the improvement mean to the standard deviation at the test input, \n    # the product of the remaining budget ratio and the distance of the predicted mean from the best observed function value, \n    # taking into account the normalized cost-effectiveness of the test input and the difference between the predicted mean and the best observed value.",
          "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    # {The new algorithm quantifies utility based on the ratio of the improvement mean to the standard deviation at the test input, \n    # the product of the remaining budget ratio and the distance of the predicted mean from the best observed function value, \n    # taking into account the normalized cost-effectiveness of the test input and the difference between the predicted mean and the best observed value.}\n    \n    # Calculate the improvement in mean prediction at the test input\n    improvement_mean = mean_test_y - best_y\n    \n    # Calculate the ratio between the improvement and standard deviation at the test input\n    ratio_improvement_std = improvement_mean / (std_test_y + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # Calculate the remaining budget ratio\n    remaining_budget_ratio = (budget_total - budget_used) / (budget_total + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # Calculate the distance of the predicted mean from the best observed function value\n    mean_distance_best = torch.abs(mean_test_y - best_y)\n    \n    # Calculate the normalized cost-effectiveness of the test input\n    norm_cost_effectiveness = cost_test_y / (torch.max(cost_test_y) + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # Combine the ratio of improvement to standard deviation, remaining budget ratio, mean distance from best, normalized cost-effectiveness to quantify the utility\n    utility_value = ratio_improvement_std * remaining_budget_ratio * mean_distance_best * norm_cost_effectiveness\n    utility_value = utility_value.squeeze()\n    \n    return utility_value",
          "objective": 2.65889,
          "other_inf": null
     },
     {
          "algorithm": "Your new algorithm: \n    # Calculate the difference between the predicted mean and the best solution,\n    diff_mean_best = mean_test_y - best_y\n    \n    # Calculate the ratio of the difference to the standard deviation at the test input,\n    ratio_diff_std = diff_mean_best / (std_test_y + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # Calculate the normalized cost-effectiveness of the test input,\n    norm_cost_effectiveness = cost_test_y / (torch.max(cost_test_y) + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # Calculate the remaining budget ratio,\n    remaining_budget_ratio = (budget_total - budget_used) / (budget_total + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # Combine the difference ratio, normalized cost-effectiveness, and remaining budget ratio to quantify the utility,\n    utility_value = torch.abs(diff_mean_best) * ratio_diff_std * norm_cost_effectiveness * remaining_budget_ratio\n    utility_value = utility_value.squeeze()\n    # ",
          "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    # {Your new algorithm: \n    # Calculate the difference between the predicted mean and the best solution,\n    diff_mean_best = mean_test_y - best_y\n    \n    # Calculate the ratio of the difference to the standard deviation at the test input,\n    ratio_diff_std = diff_mean_best / (std_test_y + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # Calculate the normalized cost-effectiveness of the test input,\n    norm_cost_effectiveness = cost_test_y / (torch.max(cost_test_y) + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # Calculate the remaining budget ratio,\n    remaining_budget_ratio = (budget_total - budget_used) / (budget_total + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # Combine the difference ratio, normalized cost-effectiveness, and remaining budget ratio to quantify the utility,\n    utility_value = torch.abs(diff_mean_best) * ratio_diff_std * norm_cost_effectiveness * remaining_budget_ratio\n    utility_value = utility_value.squeeze()\n    # }\n    \n    return utility_value",
          "objective": 3.40943,
          "other_inf": null
     }
]