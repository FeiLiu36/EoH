[
     {
          "algorithm": "New algorithm description: The new algorithm assigns scores to bins based on the ratio between the current bin's capacity and the item size, the index of the bin, and the difference between the maximum remaining capacity and the current bin's capacity divided by the item size. It also incorporates an additional factor that adjusts the scores based on the square of the ratio between the current bin's capacity and the item size, promoting assignment to bins with higher indices and closer to being full. Finally, the scores are amplified based on a factor that promotes assigning items to bins with closer to average remaining capacity, with a stronger emphasis on bins that have a remaining capacity closer to the average.\n\nHere is the Python implementation of the new score function:\n\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the maximum remaining capacity of all bins\n    max_capacity = np.max(bins)\n    \n    # Calculate the scores based on a combination of factors\n    ratio = bins / item\n    diff_factor = (np.max(bins) - bins) / item\n    scores = (item - bins) * np.arange(1, len(bins)+1)**2 * diff_factor * ratio\n    \n    # Amplify the scores based on a factor that promotes assigning items to bins with closer to average remaining capacity, with a stronger emphasis on bins that have a remaining capacity closer to the average\n    avg_ratio = np.mean(bins) / item\n    penalty_factor = 1 + (1 - np.abs(ratio)) + (np.abs(ratio - avg_ratio)**2 / avg_ratio**2)\n    scores = scores * penalty_factor\n    \n    return scores",
          "objective": 0.01539,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm description: The new algorithm adjusts the score of each bin based on a combination of factors, including the ratio between the current bin's capacity and the item size, the index of the bin, the difference between the maximum remaining capacity and the current bin's capacity divided by the item size, and the square of the ratio between the current bin's capacity and the item size. Furthermore, the scores are amplified based on a factor that promotes assigning items to bins with closer to average remaining capacity, and a penalty is applied for bins with very low remaining capacity.\n\n```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the scores based on a combination of factors\n    ratio = bins / item\n    diff_factor = (np.max(bins) - bins) / item\n\n    # Adjust the scores based on the ratio between the current bin's capacity and the item size\n    scores = (item - bins) * np.arange(1, len(bins)+1)**2 * diff_factor * ratio\n\n    # Amplify the scores based on a factor that promotes assigning items to bins with closer to average remaining capacity\n    scores = scores * (1 + (1 - np.abs(ratio)))\n\n    # Penalty factor for bins with very low remaining capacity\n    penalty = np.where(bins < item/10, 0.1, 1)\n    scores = scores * penalty\n\n    return scores",
          "objective": 0.0167,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm assigns scores to bins based on a combination of factors, including the ratio between the current bin's capacity and the item size, the index of the bin, and the difference between the maximum remaining capacity and the current bin's capacity divided by the item size. It also incorporates an additional factor that adjusts the scores based on the square of the ratio between the current bin's capacity and the item size, further promoting assignment to bins with higher indices and closer to being full. Finally, the scores are amplified based on a factor that promotes assigning items to bins with closer to average remaining capacity.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the maximum remaining capacity of all bins\n    max_capacity = np.max(bins)\n    \n    # Calculate the scores based on a combination of factors\n    ratio = bins / item\n    diff_factor = (np.max(bins) - bins) / item\n    scores = (item - bins) * np.arange(1, len(bins)+1)**2 * diff_factor * ratio\n    \n    # Amplify the scores based on a factor that promotes assigning items to bins with closer to average remaining capacity\n    avg_ratio = np.mean(bins) / item\n    penalty_factor = 1 + (1 - np.abs(ratio)) + (np.abs(ratio - avg_ratio) / avg_ratio)\n    scores = scores * penalty_factor\n    \n    return scores",
          "objective": 0.02606,
          "other_inf": null
     },
     {
          "algorithm": "\nNew algorithm description: The new algorithm assigns scores to bins based on a weighted combination of the ratio between the current bin's capacity and the average remaining capacity, the item size, the index of the bin, and the difference between the maximum remaining capacity and the current bin's capacity. It then adjusts the scores further based on a factor that promotes assigning items to bins with higher indices and closer to being full. Finally, it amplifies the scores based on the ratio between the item size and the average remaining capacity. \n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the average remaining capacity of all bins\n    avg_capacity = np.mean(bins)\n    \n    # Calculate the scores based on a weighted combination of factors\n    scores = (item - bins) * np.arange(len(bins), 0, -1) * (bins / avg_capacity) * (np.max(bins) - bins + 1)\n    \n    # Adjust the scores based on a factor that promotes assigning items to bins with higher indices and closer to being full\n    scores = scores * (1 + (np.arange(len(bins), 0, -1) / len(bins)))\n    \n    # Amplify the scores based on the ratio between the item size and the average remaining capacity\n    ratio = item / avg_capacity\n    scores = scores * (1 + ratio)\n    \n    return scores",
          "objective": 0.02646,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm assigns scores to bins based on the ratio between the current bin's capacity and the square root of the sum of all bin capacities, the item size, the index of the bin, and the difference between the maximum remaining capacity and the current bin's capacity, divided by the item size.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    sum_capacity = np.sum(bins)\n    ratio = bins / np.sqrt(sum_capacity)\n    scores = (item - bins) * np.arange(len(bins), 0, -1) * ratio * (np.max(bins) - bins + 1) / item\n    return scores",
          "objective": 0.02656,
          "other_inf": null
     }
]