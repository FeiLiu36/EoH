[
     {
          "algorithm": "New algorithm description: In the new algorithm, we modify the scoring function by introducing a penalty for bins that have higher remaining capacity and a bonus for bins with lower remaining capacity. The penalty and bonus are calculated based on the ratio of remaining capacity to the maximum capacity. The final scores for the bins are calculated by combining the base scores, remaining capacity penalty, and remaining capacity bonus. We also introduce an additional penalty for bins that have a remaining capacity close to the maximum capacity to encourage efficient utilization of bins. The new algorithm takes into account the size of the item and adjusts the penalties and bonuses accordingly.\n\nNew algorithm implementation:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    num_bins = len(bins)\n    \n    # Calculate base scores\n    base_scores = 1 - bins / item\n    \n    # Calculate penalty for bins with higher remaining capacity\n    remaining_capacity_penalty = (bins / np.max(bins)) ** 2\n    \n    # Calculate bonus for bins with lower remaining capacity\n    remaining_capacity_bonus = (1 - bins / np.max(bins)) ** 2\n    \n    # Additional penalty for bins with remaining capacity close to maximum capacity\n    additional_penalty = np.exp(-np.abs(bins - np.max(bins)) / np.max(bins))\n    \n    # Adjust penalties and bonuses based on item size\n    remaining_capacity_penalty *= (1 + item / np.max(bins)) ** 2\n    remaining_capacity_bonus *= np.log(1 + np.max(bins) / item)\n    \n    # Calculate final scores by combining base scores, penalties, and bonuses\n    scores = base_scores - remaining_capacity_penalty + remaining_capacity_bonus - additional_penalty\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]