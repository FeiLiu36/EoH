[
     {
          "algorithm": "The new algorithm calculates the weighted base scores by multiplying the difference between the remaining capacity and the item size by a weight factor, penalizes bins with higher items assigned based on a decreasing penalty rate, introduces a penalty for bins with remaining capacity close to their maximum capacity with an increasing penalty rate, and provides a bonus for bins with a large remaining capacity with an increasing bonus rate. It combines all these features to calculate the final scores for the bins.\n\nCode:\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate weighted base scores by multiplying the difference between the remaining capacity and the item size by a weight factor\n    base_scores = 0.5 * (item - bins) / item\n    \n    # Calculate penalty for bins with higher items assigned based on a decreasing penalty rate\n    high_item_penalty = np.where(bins < item, 0.1 * (item - bins) / item, 0)\n    \n    # Calculate penalty for bins with remaining capacity close to their maximum capacity with an increasing penalty rate\n    near_max_capacity_penalty = np.where(bins >= 0.8 * np.max(bins), 0.2 * (bins - 0.8 * np.max(bins)) / item, 0)\n\n    # Calculate bonus for bins with a large remaining capacity with an increasing bonus rate\n    large_capacity_bonus = np.where(bins > 1.2 * item, 0.2 * (bins - 1.2 * item) / item, 0)\n\n    # Calculate final scores by combining weighted base scores, high item penalty, near-maximum capacity penalty, and large capacity bonus\n    scores = base_scores - high_item_penalty - near_max_capacity_penalty + large_capacity_bonus\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]