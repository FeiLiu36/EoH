[
     {
          "algorithm": "My new algorithm modifies the existing algorithm by introducing a penalty for bins with a larger percentage of their maximum capacity used and provides a bonus for bins with a larger remaining capacity, while still considering the remaining capacity and average size of items assigned to each bin to minimize the number of used bins.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate base scores by subtracting the ratio of the remaining capacity to the item size from 1\n    base_scores = 1 - bins / item\n    \n    # Calculate penalty for bins with higher items assigned based on a linear decreasing penalty rate\n    high_item_penalty = np.maximum(0, (bins - item) / item)\n    \n    # Calculate penalty for bins with remaining capacity close to their maximum capacity with an increasing penalty rate\n    near_max_capacity_penalty = np.maximum(0, (1 - bins / np.max(bins)) * np.where((bins >= 0.8 * np.max(bins)), 0.2, 0))\n    \n    # Calculate bonus for bins with a larger remaining capacity\n    large_capacity_bonus = np.maximum(0, (bins - item) / item)\n    \n    # Calculate average size of items assigned to each bin\n    average_size = (np.sum(bins) - bins) / (len(bins) - 1)\n    \n    # Calculate penalty for bins with a higher average size of items assigned\n    higher_average_penalty = np.maximum(0, (bins - average_size) / average_size)\n\n    # Calculate final scores by combining base scores, high item penalty, near-maximum capacity penalty, large capacity bonus, and higher average penalty\n    scores = base_scores - high_item_penalty - near_max_capacity_penalty + large_capacity_bonus - higher_average_penalty\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]