[
     {
          "algorithm": "Algorithm: The new algorithm calculates the scores for each bin based on the reciprocal difference between the rest capacity of each bin and the item size, the logarithm of the sum of the rest capacities of all the bins, and the square root of the difference between the rest capacity of each bin and the maximum capacity among all bins. The scores for each component are multiplied by a set of weights, determined based on the proportion of the modified scores contributed by each component in the original algorithm. These scores are then adjusted with weighted components by dividing each score by the logarithm of the sum of the rest capacities of all the bins. Finally, the adjusted scores are normalized by dividing each score by the sum of all adjusted scores plus the number of bins.\n\nCode:\n\n```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    reciprocal_diff = 1 / (bins - item)\n    log_sum_rest_capacities = np.log(np.sum(bins))\n    sqrt_diff = np.sqrt(bins - np.max(bins))\n  \n    modified_scores = reciprocal_diff * 0.2 + log_sum_rest_capacities * 0.5 + sqrt_diff * 0.3\n    weights = [np.sum(modified_scores) for _ in range(3)]\n    weights = np.divide(weights, np.sum(modified_scores))\n    \n    # Adjusted scores with weighted components\n    adjusted_scores = (\n        weights[0] * np.divide(reciprocal_diff, np.log(np.sum(bins))) +\n        weights[1] * np.divide(log_sum_rest_capacities, np.log(np.sum(bins))) +\n        weights[2] * np.divide(sqrt_diff, np.log(np.sum(bins)))\n    )\n  \n    sum_modified_scores = np.sum(adjusted_scores)\n    scores = adjusted_scores / (sum_modified_scores + len(bins))\n    \n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]