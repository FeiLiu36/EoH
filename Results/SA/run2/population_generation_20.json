[
     {
          "algorithm": "The new algorithm calculates the score for each bin based on a combination of the remaining capacity and a penalty factor that depends on the item size divided by the logarithm of the remaining capacity, prioritizing bins with larger ratios. If the remaining capacity of a bin is greater than or equal to the item size, the score is set to negative infinity. Otherwise, the score is calculated as follows: item / log(remaining_capacity) + penalty_factor * item / log(remaining_capacity). The penalty factor is determined by finding the maximum item size in the list of bins and dividing it by the logarithm of the maximum remaining capacity.",
          "code": "import numpy as np\nimport math\n\ndef score(item, bins):\n    max_item_size = max(item, np.max(bins))\n    max_remaining_capacity = np.max(bins)\n    penalty_factor = max_item_size / math.log(max_remaining_capacity)\n    \n    scores = np.zeros_like(bins, dtype=float)\n    \n    for i, remaining_capacity in enumerate(bins):\n        if remaining_capacity >= item:\n            scores[i] = -np.inf\n        else:\n            scores[i] = (item / math.log(remaining_capacity)) + (penalty_factor * item / math.log(remaining_capacity))\n    \n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]