[
     {
          "algorithm": "New algorithm description: The new algorithm calculates the scores for the bins based on their rest capacity and the item size, penalizes bins with rest capacities less than a certain fraction of the item size, and gives a bonus score to bins with rest capacities greater than a certain threshold value. The final scores are then normalized to ensure self-consistency. Additionally, the algorithm introduces a weighting factor to balance the effect of the penalty and bonus scores, which is dynamically calculated based on the maximum capacity of the bins, the item size, and a user-defined parameter.\n\nNew algorithm implementation:\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_rest_capacity = np.max(bins)\n    max_capacity = np.max([item, max_rest_capacity])\n\n    # Calculate the penalty fraction dynamically based on the maximum rest capacity and item size ratio\n    penalty_fraction = max_rest_capacity / max_capacity\n\n    # Calculate the bonus threshold dynamically based on the maximum rest capacity\n    bonus_threshold = max_rest_capacity\n\n    # Calculate the scaling factor dynamically based on the penalty fraction and a user-defined parameter\n    parameter = 0.5  # User-defined parameter\n    scaling_factor = max_capacity / (max_capacity - parameter * penalty_fraction * item)\n\n    # Calculate the difference between the rest capacity and the penalty fraction of the item size\n    capacity_diff = bins - penalty_fraction * item\n\n    # Penalize bins with rest capacities less than a fraction of the item size by reducing their scores to zero\n    capacity_diff[capacity_diff <= 0] = 0\n\n    # Adjust the scores using the capacity difference and scaling factor\n    adjusted_scores = scaling_factor * capacity_diff\n\n    # Normalize the adjusted scores to ensure self-consistency\n    normalized_scores = adjusted_scores / np.sum(adjusted_scores)\n\n    # Assign bonus scores based on the rest capacity of each bin\n    bonus_scores = np.where(bins > bonus_threshold, bins - item, 0)\n\n    # Normalize the bonus scores to ensure self-consistency\n    normalized_bonus_scores = bonus_scores / np.sum(bonus_scores)\n\n    # Combine the adjusted scores and normalized bonus scores\n    scores = normalized_scores + normalized_bonus_scores\n\n    # Normalize the final scores to ensure self-consistency\n    scores /= np.sum(scores)\n\n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]