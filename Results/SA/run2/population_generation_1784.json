[
     {
          "algorithm": "Algorithm: \n\nThe new algorithm calculates the scores for the bins based on their remaining capacities after assigning the item. It uses a modified version of the previous algorithm, where the scores are determined by taking the negative of the square root of the ratio of the remaining capacity to the maximum capacity, multiplied by a penalty factor based on the difference between the remaining capacity and the item size. The penalty factor is a function of the difference between the remaining capacity and the item size, where larger differences result in larger penalty values. Finally, the scores of bins that are not used are set to a large negative value.\n\nCode:\n\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Create an array 'sizes' with the size of 'bins' and initialize it with 'item'\n    sizes = np.full_like(bins, item)\n    \n    # Find the indices of bins that have remaining capacity greater than or equal to 'sizes'\n    indices = np.where(bins >= sizes)[0]\n    \n    # Calculate the penalty factor based on the difference between the remaining capacity and the item size\n    penalty_factor = np.sqrt(np.maximum(bins[indices] - sizes[indices], 0))\n    \n    # Calculate the scores for the eligible bins based on the division of remaining capacities by the maximum capacity,\n    # multiplied by the penalty factor\n    scores = -np.sqrt(bins[indices] / np.max(bins)) * penalty_factor\n    \n    # Create an array 'output_scores' with the size of 'bins' and initialize it with a large negative value\n    output_scores = np.full_like(bins, -np.inf)\n    \n    # Set the scores of eligible bins to their corresponding values in 'scores'\n    output_scores[indices] = scores\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]