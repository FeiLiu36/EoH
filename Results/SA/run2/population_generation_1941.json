[
     {
          "algorithm": "Description: My new algorithm calculates the scores for the bins based on a combination of four penalty factors. The first penalty factor incorporates information about the remaining capacity and the maximum capacity, giving more weight to bins with larger remaining capacities and a penalty for unused bins. The second penalty factor takes into account the ratio of the item size to the remaining capacity, penalizing bins with insufficient capacity for the item. The third penalty factor considers the number of items already assigned to each bin, giving more weight to bins with fewer items. The fourth penalty factor penalizes bins that have already reached a certain threshold of assigned items. The scores are then adjusted based on these penalty factors and normalized to fall within the range [0, 1].\n\nCode:\n\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate the remaining capacity of the bins\n    remaining_capacity = bins - item\n    \n    # Calculate the first penalty factor that takes into account remaining capacity and maximum capacity, with extra penalty for unused bins\n    first_penalty_factor = (remaining_capacity**2) / (bins**2) * (np.where(bins-item > 0, 1, 2))\n    \n    # Calculate the second penalty factor that penalizes bins with insufficient capacity for the item\n    second_penalty_factor = np.where(remaining_capacity >= 0, 1, 0)\n    \n    # Calculate the third penalty factor based on the number of items already assigned to each bin\n    num_items = bins.size - np.count_nonzero(remaining_capacity)\n    third_penalty_factor = np.exp(-num_items)\n    \n    # Calculate the fourth penalty factor that penalizes bins with already assigned items above a threshold\n    fourth_penalty_factor = np.where(num_items < bins.size * 0.5, 1, 0.5)\n    \n    # Calculate the ratio of item size to remaining capacity\n    ratio = item / remaining_capacity\n    \n    # Assign scores to the bins based on the product of the four penalty factors and the ratio\n    scores = ratio * first_penalty_factor * second_penalty_factor * third_penalty_factor * fourth_penalty_factor\n    \n    # Normalize the scores to fall within the range [0, 1]\n    min_score = np.min(scores)\n    max_score = np.max(scores)\n    normalized_scores = (scores - min_score) / (max_score - min_score)\n    \n    return scores",
          "objective": 0.0156,
          "other_inf": null
     }
]