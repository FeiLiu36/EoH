[
     {
          "algorithm": "Algorithm Description: The modified algorithm assigns scores to the bins based on the inverse of the sum of the rest capacity and the maximum capacity of each bin, a penalty factor that accounts for the square of the ratio of the item size to the sum of the rest capacity and the maximum capacity of each bin, a scaling factor that considers the difference between the sum of the rest capacity and the maximum capacity, and an additional factor that penalizes low rest capacities to promote better bin utilization. The final scores are adjusted to ensure self-consistency by normalizing them to the sum of the adjusted scores, and the output scores are sorted in descending order.\n\nCode:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate the sum of the rest capacity and the maximum capacity of each bin\n    sum_capacity = bins + np.max(bins)\n\n    # Calculate the square of the ratio of the item size to the sum of the rest capacity and the maximum capacity of each bin\n    ratio = item / sum_capacity\n    ratio_square = np.power(ratio, 2)\n\n    # Calculate the penalty factor based on the square ratio of the item size to the sum of the rest capacity and the maximum capacity of each bin\n    penalty_factor = ratio_square / np.max(ratio_square)\n\n    # Calculate the difference between the sum of the rest capacity and the maximum capacity\n    difference = sum_capacity - np.max(bins)\n\n    # Calculate an additional factor to penalize low rest capacities\n    low_capacity_penalty = np.exp(-bins / np.max(bins))\n\n    # Calculate the adjusted scores based on the inverse of the sum of the rest capacity and the maximum capacity, the penalty factor, the difference, and the low capacity penalty\n    adjusted_scores = 1 / sum_capacity * penalty_factor * difference * low_capacity_penalty\n\n    # Normalize the adjusted scores to ensure self-consistency\n    scores = adjusted_scores / np.sum(adjusted_scores)\n\n    # Sort the scores in descending order\n    scores = np.sort(scores)[::-1]\n\n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]