[
     {
          "algorithm": "New Algorithm: The new algorithm assigns scores to the bins based on the ratio of the item size to the rest capacities of each bin raised to the power of the reciprocal of the square root of the sum of the squares of the inverse of the rest capacities of all bins, multiplied by the penalty factor based on the square root of the inverse of the rest capacity of each bin. The final scores are normalized to ensure self-consistency.\n\nHere is the implementation of the new algorithm in Python:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    inverse_rest_capacities = 1 / bins\n    sum_squares_inverse = np.sum(np.square(inverse_rest_capacities))\n    sqrt_sum_squares_inverse = np.sqrt(sum_squares_inverse)\n    \n    # Calculate the penalty factor dynamically based on the square root of the inverse of the rest capacity of each bin\n    penalty_factor = np.sqrt(inverse_rest_capacities)\n    \n    # Calculate the adjusted scores based on the ratio of item size to the rest capacities of each bin\n    adjusted_scores = np.power(item / bins, 1 / sqrt_sum_squares_inverse) * penalty_factor\n    \n    # Normalize the adjusted scores to ensure self-consistency\n    scores = adjusted_scores / np.sum(adjusted_scores)\n\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]