[
     {
          "algorithm": "The new algorithm calculates the scores for the bins based on the following steps: \n1. Calculate the base scores by subtracting the remaining capacity of each bin from the item size, and subtracting the mean of the remaining capacities from each base score. \n2. Calculate the penalty for bins that already have higher items assigned. \n3. Calculate the bonus for bins with remaining capacity close to their maximum capacity, based on the logarithm of the remaining capacity. \n4. Calculate the final scores by combining the base scores, higher item penalty, and near-maximum capacity bonus. \n5. Return the scores array.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate base scores by subtracting remaining capacity from item size and the mean of remaining capacities\n    base_scores = item - bins - np.mean(bins)\n    \n    # Penalty for bins that already have higher items assigned\n    higher_item_penalty = np.where(bins < item, 0.3 * item, 0)\n    \n    # Bonus for bins with remaining capacity close to their maximum capacity, based on the logarithm of remaining capacity\n    near_max_capacity_bonus = np.where(bins >= (np.max(bins) * 0.8), np.log(bins), 0)\n    \n    # Calculate final scores by combining base scores, higher item penalty, and near-maximum capacity bonus\n    scores = base_scores - higher_item_penalty + near_max_capacity_bonus\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]