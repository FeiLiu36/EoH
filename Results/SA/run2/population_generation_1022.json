[
     {
          "algorithm": "\nThe new algorithm is a modified version of the original algorithm and involves the following steps:\n1. Calculate the remaining capacity of each bin by subtracting the item size from the rest capacities of feasible bins.\n2. Compute the maximum capacity and average capacity of all the bins.\n3. Calculate a ratio score for each bin by dividing its remaining capacity by the maximum capacity.\n4. Calculate a penalty score for each bin based on two penalty terms: a penalty that penalizes bins with a large remaining capacity compared to the average capacity and a penalty that penalizes bins with a large difference in remaining capacity compared to the average capacity.\n5. Calculate a reward score for each bin by taking the difference between the item size and the remaining capacity.\n6. Calculate a priority score for each bin by dividing its remaining capacity by the maximum capacity.\n7. Scale the penalty scores by multiplying them with a scaling factor based on the maximum capacity and the average capacity.\n8. Calculate a difference score for each bin based on the absolute difference between its remaining capacity and the average capacity.\n9. Compute the final score for each bin by summing up the ratio score, scaled penalty scores, reward score, priority score, scaling factor, and difference score.\n10. Return the scores for the bins for assignment.\n\nThe new algorithm aims to balance the utilization of bins by penalizing those with excessive remaining capacity, while also rewarding bins with smaller remaining capacity compared to the item size, prioritizing bins with larger remaining capacities, and considering the difference in remaining capacity compared to the average capacity.\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    max_capacity = np.max(bins)\n    avg_capacity = np.mean(bins)\n    \n    ratio_score = remaining_capacity / max_capacity\n    \n    penalty_score_1 = np.maximum(0, remaining_capacity - avg_capacity)\n    \n    penalty_score_2 = np.exp(np.abs(remaining_capacity - avg_capacity) / avg_capacity)\n    \n    reward_score = np.maximum(0, item - remaining_capacity)\n    \n    priority_score = remaining_capacity / max_capacity\n    \n    scaling_factor = max_capacity / (np.max(bins) - avg_capacity)\n    \n    difference_score = np.abs(remaining_capacity - avg_capacity)\n    \n    scaled_penalty = penalty_score_1 * penalty_score_2 * 0.5\n    \n    scores = ratio_score + scaled_penalty + reward_score + priority_score + scaling_factor + difference_score\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]