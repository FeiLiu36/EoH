[
     {
          "algorithm": "New Algorithm description: In the new algorithm, we modify the existing algorithm by introducing a penalty for bins with larger remaining capacity, providing a bonus for bins with a smaller average size of items assigned, and incorporating a penalty for bins with a higher utilization rate. We also introduce an additional penalty for bins with a smaller remaining capacity, to further encourage the utilization of bins with larger remaining capacity. The final scores for the bins are calculated by combining the base scores, high item penalty, average size bonus, remaining capacity penalty, utilization penalty, and remaining capacity penalty 2.\n\nCode:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate base scores\n    base_scores = 1 - bins / item\n    \n    # Calculate penalty for bins with larger remaining capacity\n    remaining_capacity_penalty = np.maximum(0, (bins - item) / bins)\n    \n    # Calculate bonus for bins with a smaller average size of items assigned\n    average_size = (np.sum(bins) - bins) / (len(bins) - 1)\n    tiny_average_bonus = np.maximum(0, (average_size - bins) / average_size)\n    \n    # Calculate penalty for bins with a higher utilization rate\n    utilization_penalty = np.maximum(0, (1 - bins / np.max(bins)) * np.where((bins >= 0.8 * np.max(bins)), 0.2, 0))\n    \n    # Calculate penalty for bins with smaller remaining capacity\n    remaining_capacity_penalty2 = np.maximum(0, (bins - item) / np.max(bins))\n    \n    # Calculate final scores by combining base scores, remaining capacity penalty, average size bonus, utilization penalty, and remaining capacity penalty 2\n    scores = base_scores - remaining_capacity_penalty + tiny_average_bonus - utilization_penalty - remaining_capacity_penalty2\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]