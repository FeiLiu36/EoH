[
     {
          "algorithm": "New algorithm description: The new algorithm computes the scores for each bin based on a weighted combination of the logarithm of the absolute difference between the rest capacity of each bin and the item size, the square root of the sum of the rest capacities of all the bins, and the inverse of the square of the difference between the rest capacity of each bin and the maximum capacity among all bins. The weights for each component are determined by the proportion of the modified scores contributed by each component in the original algorithm.\n\nCode:\n\n```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    log_diff = np.log(np.abs(bins - item))\n    sqrt_sum_rest_capacities = np.sqrt(np.sum(bins))\n    inverse_square_diff = 1 / np.square(bins - np.max(bins))\n  \n    modified_scores = np.maximum(log_diff, sqrt_sum_rest_capacities, inverse_square_diff)\n    weights = [np.sum(modified_scores) for _ in range(3)]\n    weights = np.divide(weights, np.sum(modified_scores))\n  \n    modified_scores = np.power(modified_scores, 2)\n    \n    # Adjusted scores with weighted components\n    adjusted_scores = (\n        weights[0] * np.divide(log_diff, (1 + np.exp(bins - np.mean(bins)))) +\n        weights[1] * np.divide(sqrt_sum_rest_capacities, (1 + np.exp(bins - np.mean(bins)))) +\n        weights[2] * np.divide(inverse_square_diff, (1 + np.exp(bins - np.mean(bins))))\n    )\n  \n    sum_modified_scores = np.sum(adjusted_scores)\n    scores = adjusted_scores / (sum_modified_scores + len(bins))\n    \n    return scores",
          "objective": 0.03874,
          "other_inf": null
     }
]