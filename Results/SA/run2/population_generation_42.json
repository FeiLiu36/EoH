[
     {
          "algorithm": "New algorithm: \n\nThe modified algorithm calculates the score for each bin based on the remaining capacity, a penalty factor, and a priority factor. It prioritizes bins with larger remaining capacities and adjusts the score based on the penalty factor and priority factor. Bins with remaining capacity less than the item size are assigned a low score. The penalty factor is calculated as the negative exponential of the remaining capacity divided by the priority factor. The algorithm then adds a penalty to bins with remaining capacity less than half of the maximum remaining capacity. Additionally, it introduces a new component that penalizes bins with a remaining capacity close to the maximum remaining capacity to encourage more even distribution of items across bins.\n\n\nPython implementation:\n\n```\n",
          "code": "import numpy as np\nimport math\n\ndef score(item, bins):\n    max_item_size = item\n    max_remaining_capacity = np.max(bins)\n    priority_factor = max_remaining_capacity / max_item_size\n    penalty_factor = -np.exp(-bins / priority_factor)\n\n    scores = np.zeros(len(bins), dtype=np.float64)\n\n    low_capacity_bins = bins < item\n    scores[low_capacity_bins] = -np.inf\n    scores[~low_capacity_bins] = bins[~low_capacity_bins] * priority_factor - np.square(item)\n    scores[~low_capacity_bins] = np.sqrt(scores[~low_capacity_bins]) * penalty_factor[~low_capacity_bins]\n\n    half_max_remaining_capacity = max_remaining_capacity / 2\n\n    penalty = np.ones(len(bins), dtype=np.float64) * -np.inf\n    penalty[bins < half_max_remaining_capacity] = -np.square(max_remaining_capacity - bins[bins < half_max_remaining_capacity])\n\n    penalty_close_to_max = np.square(bins - max_remaining_capacity) / max_remaining_capacity\n    scores += penalty + penalty_close_to_max\n\n    return scores",
          "objective": 0.04689,
          "other_inf": null
     }
]