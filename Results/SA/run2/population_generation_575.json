[
     {
          "algorithm": "New algorithm description:\n\nIn the new algorithm, we modify the scoring function by introducing a penalty for bins with higher remaining capacity, providing a bonus for bins with a smaller average remaining capacity, and incorporating a penalty for bins that are close to their maximum capacity. We also introduce an additional penalty for bins with smaller remaining capacity compared to the maximum capacity, to encourage the utilization of bins with larger remaining capacity. The final scores for the bins are calculated by combining the base scores, remaining capacity penalty, average remaining capacity bonus, and utilization penalty.\n\nCode:\n\n```\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    num_bins = len(bins)\n    \n    # Calculate base scores\n    base_scores = 1 - bins / item\n    \n    # Calculate penalty for bins with higher remaining capacity\n    remaining_capacity_penalty = np.maximum(0, (bins - item) / np.max(bins))\n    \n    # Calculate bonus for bins with a smaller average remaining capacity\n    average_remaining_capacity = (np.sum(bins) - bins) / (num_bins - 1)\n    smaller_average_bonus = np.maximum(0, (average_remaining_capacity - bins) / average_remaining_capacity)\n    \n    # Calculate penalty for bins that are close to their maximum capacity\n    utilization_penalty = np.maximum(0, (1 - bins / np.max(bins)) * np.where((bins >= 0.8 * np.max(bins)), 0.2, 0))\n    \n    # Calculate final scores by combining base scores, remaining capacity penalty, average remaining capacity bonus, and utilization penalty\n    scores = base_scores - remaining_capacity_penalty + smaller_average_bonus - utilization_penalty\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]