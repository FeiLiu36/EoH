[
     {
          "algorithm": "New Algorithm Description: The modified algorithm assigns items to bins by calculating the score for each bin based on the ratio of remaining capacity to the item size, a penalty term for bins that have a remaining capacity less than a certain threshold, and a bonus for bins that have a remaining capacity close to their maximum capacity. Additionally, the modified algorithm considers the ratio of item size to bin capacity, where higher ratios are penalized. The algorithm then normalizes the scores to maintain self-consistency and returns the calculated scores for each bin.\n\nNew Algorithm Implementation:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    \n    # Calculate weights based on ratio of remaining capacity to item size\n    weights = np.power(remaining_capacity / item, 2)\n    normalized_weights = weights / np.sum(weights) # Normalize weights within [0, 1] to maintain self-consistency\n    \n    # Penalty for bins with remaining capacity less than 10% of maximum capacity\n    near_full_capacity_penalty = np.where(remaining_capacity < (np.max(bins) * 0.1), 0.5 * np.max(bins), 0)\n    \n    # Calculate the ratio of item size to bin capacity and penalize higher ratios\n    ratio_penalty = np.where(bins != 0, np.power(item / bins, 3), 0)\n    \n    # Bonus for bins with remaining capacity close to their maximum capacity\n    near_max_capacity_bonus = np.where(remaining_capacity == (np.max(bins) * 0.9), 0.2 * np.max(bins), 0)\n    \n    scores = normalized_weights + near_full_capacity_penalty + ratio_penalty - near_max_capacity_bonus\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]