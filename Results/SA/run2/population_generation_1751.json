[
     {
          "algorithm": "The new algorithm calculates the scores for the bins based on the remaining capacity of the bin after assigning the item, and penalizes the bins with larger remaining capacities by taking the reciprocal of their square root, while also considering a penalty factor for bins that are not used.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate the remaining capacities of the bins after assigning the item\n    remaining_capacity = bins - item\n    \n    # Calculate the penalty factor for bins that are not used\n    penalty = np.where(remaining_capacity >= bins, 0.1, 1)\n    \n    # Calculate the modified scores for the bins\n    scores = np.reciprocal(np.sqrt(remaining_capacity)) * penalty\n    \n    # Replace NaN values with a large negative value to avoid errors in assignment\n    scores[np.isnan(scores)] = -np.inf\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]