[
     {
          "algorithm": "Algorithm description: \n\nThe modified algorithm calculates a score for each bin based on the bin's remaining capacity relative to the item size, the bin's average capacity, and a penalty term based on the difference between the maximum capacity and the remaining capacity. The algorithm then assigns the item to the bin with the maximum score. If multiple bins have the same maximum score, the bin with the maximum remaining capacity is chosen.\n\nHere is the implementation of the modified algorithm:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    avg_capacity = np.mean(bins)\n    max_capacity = np.max(bins)\n\n    item_size_ratio = item / remaining_capacity\n\n    remaining_capacity_score = np.power(item_size_ratio, 2)\n    avg_capacity_score = np.power(avg_capacity / remaining_capacity, 2)\n    penalty_score = np.power((max_capacity - remaining_capacity) / max_capacity, 2)\n\n    scores = remaining_capacity_score + avg_capacity_score + penalty_score\n\n    sorted_indices = np.lexsort((-scores, -remaining_capacity))\n    sorted_scores = scores[sorted_indices]\n\n    assigned_scores = np.where(sorted_scores >= item, sorted_scores, np.inf)\n\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]