[
     {
          "algorithm": "The new algorithm aims to prioritize bins with higher remaining capacity while also penalizing bins that cannot accommodate the current item.\n\nAlgorithm description:\n\nThe new algorithm assigns a score to each bin based on their remaining capacity and their ability to accommodate the item. The main steps are as follows:\n\n1. Find the maximum remaining capacity among the bins.\n2. Calculate a priority factor for each bin by dividing its remaining capacity by the item size.\n3. Initialize an array of scores with zeros.\n4. For each bin:\n   a. If the remaining capacity is less than the item size:\n      - Set the score for that bin to -inf (negative infinity) to indicate that it cannot accommodate the item.\n   b. If the remaining capacity is equal to the maximum capacity:\n      - Set the score for that bin to -inf to exclude it from being used.\n   c. If the bin can accommodate the item:\n      - Calculate the score by multiplying the remaining capacity by the priority factor and subtracting the square of the item size.\n5. Multiply the scores by 1 for bins that can accommodate the item and by infinity for bins that cannot.\n6. Return the resulting scores array.\n\nCode:\n\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    max_remaining_capacity = np.max(bins)\n    priority_factor = max_remaining_capacity / item\n\n    low_capacity_bins = bins < item\n\n    scores = np.zeros(len(bins), dtype=np.float64)\n    scores[low_capacity_bins] = -np.inf\n    scores[bins == max_remaining_capacity] = -np.inf\n    scores[~(low_capacity_bins | (bins == max_remaining_capacity))] = bins[~(low_capacity_bins | (bins == max_remaining_capacity))] * priority_factor - np.power(item, 2)\n\n    scores = scores * (1 - (low_capacity_bins | (bins == max_remaining_capacity))) + (low_capacity_bins | (bins == max_remaining_capacity)) * np.inf\n\n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]