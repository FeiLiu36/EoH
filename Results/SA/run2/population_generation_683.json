[
     {
          "algorithm": "New algorithm description: The new algorithm adjusts the scores for the bins based on their rest capacity and the item size, penalizes bins with rest capacities less than a fraction of the item size, and gives a bonus score to bins with rest capacities greater than a certain threshold value. The final scores are then normalized to ensure self-consistency. Additionally, the algorithm assigns higher scores to bins with larger rest capacities, proportional to the difference between the rest capacity and the item size. However, in this new algorithm, rather than using a fixed penalty fraction, bonus threshold, and scaling factor, these values are calculated dynamically based on the maximum rest capacity of the bins and the maximum capacity of the bins and the item size ratio.\n\nNew algorithm implementation:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_rest_capacity = np.max(bins)\n    max_capacity = np.max([max_rest_capacity, item])\n    \n    penalty_fraction = max_rest_capacity / max_capacity\n    bonus_threshold = max_rest_capacity\n    \n    scaling_factor = 1 - penalty_fraction\n    \n    # Calculate the difference between the rest capacity and the penalty fraction of the item size\n    capacity_diff = bins - penalty_fraction * item\n    \n    # Penalize bins with rest capacities less than a fraction of the item size by reducing their scores to zero\n    capacity_diff[capacity_diff <= 0] = 0\n    \n    # Calculate the difference between the rest capacity and the item size\n    capacity_diff2 = bins - item\n    \n    # Adjust the scores using the capacity difference\n    adjusted_scores = scaling_factor * capacity_diff + scaling_factor * capacity_diff2\n    \n    # Normalize the adjusted scores to ensure self-consistency\n    normalized_scores = adjusted_scores / np.sum(adjusted_scores)\n    \n    # Assign bonus scores based on the rest capacity of each bin\n    bonus_scores = np.where(bins > bonus_threshold, 1 / bins, 0)\n    \n    # Normalize the bonus scores to ensure self-consistency\n    normalized_bonus_scores = bonus_scores / np.sum(bonus_scores)\n    \n    # Combine the adjusted scores and normalized bonus scores\n    scores = normalized_scores + normalized_bonus_scores\n    \n    # Normalize the final scores to ensure self-consistency\n    scores /= np.sum(scores)\n    \n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]