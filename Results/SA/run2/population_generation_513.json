[
     {
          "algorithm": "The new algorithm calculates the scores for the bins based on the following steps:\n\n1. Calculate the remaining capacity of each bin by subtracting the item size from the rest capacities of feasible bins.\n2. Calculate the weights based on the logarithm of the ratio of the remaining capacity to the item size.\n3. Normalize the weights within the range of [0, 1] to maintain self-consistency.\n4. Calculate the penalty for bins with a higher ratio of item size to bin capacity squared, and penalize higher ratios.\n5. Calculate the penalty for bins that already have higher items assigned.\n6. Calculate the bonus for bins with remaining capacity close to their maximum capacity.\n7. Calculate the scores by combining the weights, ratio penalty, higher item penalty, and near-maximum capacity bonus.\n8. Return the scores array.\n\nHere is the implementation of the updated score function:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    \n    # Calculate weights based on the logarithm of the ratio of remaining capacity to item size\n    weights = np.log(remaining_capacity / item)\n    \n    # Normalize weights within [0, 1] to maintain self-consistency\n    weights = weights / np.sum(weights)\n    \n    # Calculate the penalty for bins with higher ratios of item size to bin capacity squared\n    ratio_penalty = np.where(bins != 0, np.power(item / bins, 2), 0)\n    \n    # Penalty for bins that already have higher items assigned\n    higher_item_penalty = np.where(bins < item, 0.3 * item, 0)\n    \n    # Bonus for bins with remaining capacity close to their maximum capacity\n    near_max_capacity_bonus = np.where(remaining_capacity >= (np.max(bins) * 0.8), 0.15 * np.max(bins), 0)\n    \n    scores = weights + ratio_penalty - higher_item_penalty + near_max_capacity_bonus\n    \n    return scores",
          "objective": 0.03894,
          "other_inf": null
     }
]