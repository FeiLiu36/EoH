[
     {
          "algorithm": "A modified version of the algorithm is created where the scores of the bins are determined based on the difference between the rest capacity and the item size, considering the square root of the item size and a penalty factor that penalizes bins with rest capacities less than a fixed fraction of the maximum capacity. The scores are then adjusted based on the weighted ratio of the rest capacities to the maximum capacity and the maximum capacity itself. The final scores are normalized to ensure self-consistency.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_rest_capacity = np.max(bins)\n    max_capacity = np.max([item, max_rest_capacity])\n\n    # Calculate the penalty fraction dynamically based on the maximum capacity\n    penalty_fraction = max_rest_capacity / max_capacity\n\n    # Calculate the adjusted scores based on the difference between the rest capacity and the item size,\n    # the square root of the item size, and the penalty factor\n    adjusted_scores = (bins - item) * np.sqrt(item) * (1 - penalty_fraction)\n\n    # Calculate the weighted ratio of the rest capacities to the maximum capacity\n    rest_capacity_ratio = bins / max_capacity\n\n    # Create a new array of scores\n    scores = np.zeros(len(bins))\n\n    # Iterate through each bin\n    for i in range(len(bins)):\n        # Assign the score based on the adjusted score and the rest capacity ratio\n        scores[i] = adjusted_scores[i] * rest_capacity_ratio[i]\n\n    # Normalize the final scores to ensure self-consistency\n    scores /= np.sum(scores)\n\n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]