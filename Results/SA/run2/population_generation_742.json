[
     {
          "algorithm": "New Algorithm: The new algorithm assigns scores to the bins based on the product of the inverse of the rest capacities of each bin and the logarithm of the ratio of the item size to the maximum rest capacity, divided by the square root of the ratio of the item size to the maximum rest capacity, and the penalty factor based on the square root of the inverse of the rest capacity of each bin. The final scores are normalized to ensure self-consistency.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_rest_capacity = np.max(bins)\n    max_capacity = np.max([item, max_rest_capacity])\n    ratio = item / max_rest_capacity\n    sqrt_ratio = np.sqrt(ratio)\n\n    # Calculate the penalty factor dynamically based on the square root of the inverse of the rest capacity of each bin\n    penalty_factor = np.sqrt(1 / bins)\n\n    # Calculate the adjusted scores based on the product of the inverse of the rest capacities of each bin\n    # and the logarithm of the ratio of the item size to the maximum rest capacity, divided by the square root of the ratio\n    # of the item size to the maximum rest capacity, and the penalty factor\n    adjusted_scores = (1 / bins) * np.log(ratio) / sqrt_ratio * penalty_factor\n    \n    # Normalize the adjusted scores to ensure self-consistency\n    scores = adjusted_scores / np.sum(adjusted_scores)\n\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]