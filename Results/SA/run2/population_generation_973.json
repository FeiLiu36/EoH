[
     {
          "algorithm": "New algorithm description: The Weighted Capacity Score Algorithm with Displacement Penalty aims to assign items to bins by considering the difference in capacities and penalizing bins with large differences and low ratios of remaining capacity, as well as considering the displacement penalty for each bin based on its position in the array.\n\nCode:\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Create an array of indices representing the position of each bin\n    indices = np.arange(len(bins))\n\n    # Calculate the remaining capacities of the bins\n    remaining_capacity = bins - item\n\n    # Calculate the maximum capacity among the bins\n    max_capacity = np.max(bins)\n\n    # Calculate the average capacity of the bins\n    avg_capacity = np.mean(bins)\n\n    # Calculate the difference between the remaining capacity of each bin and the average capacity\n    diff_capacity = remaining_capacity - avg_capacity\n\n    # Calculate the weight for each bin based on the difference in capacities using an exponential function\n    weights = np.exp(-diff_capacity)\n\n    # Calculate the ratio of the remaining capacity of each bin to the maximum capacity\n    capacity_ratio = remaining_capacity / max_capacity\n\n    # Calculate the score based on the weighted capacity differences and the capacity ratio, penalizing large differences, low ratios, and displacement penalties\n    displacement_penalty = (indices - np.argmin(bins)) / len(bins)\n    scores = (np.exp(-((diff_capacity / max_capacity) + 0.5) / (1 - capacity_ratio)) * weights) - (0.5 * (diff_capacity / max_capacity)) - (0.2 * displacement_penalty)\n\n    # Minimize the score of bins with remaining capacity equal to the maximum capacity\n    scores[remaining_capacity == max_capacity] = -np.inf\n\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]