[
     {
          "algorithm": "The new algorithm calculates the score for each bin based on the remaining capacity, the ratio of the remaining capacity to the item size, and a penalty factor for bins close to the maximum capacity. In this modified version, the penalty factor is adjusted to give higher penalties for bins closer to the maximum capacity compared to the previous algorithm. The new algorithm also introduces a regularization term that penalizes bins with large remaining capacities.\n\nHere is the implementation of the new algorithm in Python:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate the remaining capacity\n    remaining_capacity = bins - item\n    \n    # Calculate the weight for the remaining capacity\n    remaining_weight = remaining_capacity / np.max(bins)\n    \n    # Calculate the weight for the ratio of remaining capacity to item size\n    item_size_weight = 1 - np.abs(remaining_capacity) / item\n    \n    # Calculate the penalty factor for bins close to maximum capacity (with higher penalty)\n    penalty_factor = np.exp(-np.square(remaining_capacity) / np.square(np.max(bins)))\n    \n    # Calculate the regularization term to penalize bins with large remaining capacities\n    regularization_term = np.exp(-np.square(remaining_capacity) / np.square(np.mean(bins)))\n    \n    # Initialize an array to store the scores\n    scores = np.zeros_like(bins)\n        \n    # Calculate the scores for each bin\n    scores[bins >= item] = np.multiply(np.multiply(remaining_weight[bins >= item], item_size_weight[bins >= item]), np.multiply(penalty_factor[bins >= item], regularization_term[bins >= item]))\n    \n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]