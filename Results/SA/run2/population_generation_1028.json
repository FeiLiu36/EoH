[
     {
          "algorithm": "New algorithm description: The Improved Bin Assignment Algorithm\n\n1. Initialize an empty array to store the scores for each bin.\n2. Calculate the remaining capacity of each bin by subtracting the item size from the rest capacities of feasible bins.\n3. Compute the maximum capacity and average capacity of all the bins.\n4. Calculate a penalty score for each bin based on the squared difference between its remaining capacity and the average capacity, penalizing large differences.\n5. Calculate a reward score for each bin by subtracting the remaining capacity from the item size multiplied by a weight factor, valuing bins with smaller remaining capacity.\n6. Calculate a priority score for each bin by taking the reciprocal of its remaining capacity.\n7. Scale the penalty scores by multiplying them with a scaling factor based on the difference between the maximum capacity and the average capacity.\n8. Calculate a difference score for each bin based on the absolute difference between its remaining capacity and the average capacity.\n9. Compute the final score for each bin by summing up the penalty scores, reward scores, priority scores, scaling factor, and difference scores.\n10. Rank the bins based on their final scores.\n11. Start assigning the highest-ranked bin to the item until its size exceeds the remaining capacity of the bin.\n12. If the item cannot be assigned to any bin, create a new bin with an initial rest capacity of the maximum capacity and assign the item to it.\n13. After all items have been assigned, return the scores for the bins for assignment.\n\nHere's the implementation of the new algorithm in Python:\n\nCode:\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    scores = np.empty(len(bins))\n    remaining_capacity = bins - item\n    max_capacity = np.max(bins)\n    avg_capacity = np.mean(bins)\n    \n    penalty_score = np.square(remaining_capacity - avg_capacity)\n    \n    reward_score = item - remaining_capacity * 0.5\n    \n    priority_score = 1 / remaining_capacity\n    \n    scaling_factor = max_capacity - avg_capacity\n    \n    difference_score = np.abs(remaining_capacity - avg_capacity)\n    \n    scores = penalty_score + reward_score + priority_score + scaling_factor + difference_score\n    \n    sorted_indices = np.argsort(scores)[::-1]\n    sorted_bins = bins[sorted_indices]\n    \n    assigned_bins = []\n    for bin_capacity in sorted_bins:\n        if item <= bin_capacity:\n            assigned_bins.append(bin_capacity)\n            break\n    else:\n        assigned_bins.append(max_capacity)\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]