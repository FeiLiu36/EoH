[
     {
          "algorithm": "My new algorithm is a modified version of the provided algorithm where instead of calculating the weights based on an exponential transformation of the ratio of remaining capacity to item size, I will calculate the weights based on the logarithm of the ratio of remaining capacity to item size. Additionally, I will remove the penalty for bins with remaining capacity less than 20% of the maximum capacity, and I will provide a bonus for bins with remaining capacity close to their maximum capacity. The main steps of the algorithm are as follows:",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    \n    # Calculate weights based on the logarithm of the ratio of remaining capacity to item size\n    weights = np.log(remaining_capacity / item)\n    \n    # Normalize weights within [0, 1] to maintain self-consistency\n    weights = weights / np.sum(weights)\n    \n    # Calculate the ratio of item size to bin capacity squared and penalize higher ratios\n    ratio_penalty = np.where(bins != 0, np.power(item / bins, 2), 0)\n    \n    # Penalty for bins that already have higher items assigned\n    higher_item_penalty = np.where(bins < item, 0.3 * item, 0)\n    \n    # Bonus for bins with remaining capacity close to their maximum capacity\n    near_max_capacity_bonus = np.where(remaining_capacity >= (np.max(bins) * 0.8), 0.15 * np.max(bins), 0)\n    \n    scores = weights + ratio_penalty - higher_item_penalty + near_max_capacity_bonus\n    \n    return scores",
          "objective": 0.03894,
          "other_inf": null
     }
]