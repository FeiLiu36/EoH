[
     {
          "algorithm": "\nNew algorithm: \n    This modified algorithm assigns scores to each bin based on the remaining capacity of the bin, the item size, and a factor that represents the ratio of the remaining capacity to the item size. The scores are calculated by subtracting this factor from the maximum possible score, and then sorting the scores in descending order before returning them.\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate the remaining capacity after assigning the item to each bin\n    remaining_capacity = bins - item\n    \n    # Calculate the ratio of remaining_capacity to item size\n    ratio = remaining_capacity / item\n    \n    # Create a mask to identify bins with maximum capacity\n    mask = remaining_capacity < np.max(bins)\n    \n    # Calculate the maximum possible score based on the remaining capacity\n    max_score = np.max(ratio)\n    \n    # Initialize the scores array with all zeros\n    scores = np.zeros_like(remaining_capacity)\n    \n    # Calculate the scores for bins with non-maximum capacity\n    scores[mask] = max_score - ratio[mask]\n    \n    # Sort the scores in descending order\n    sorted_indices = np.argsort(scores)[::-1]\n    scores = scores[sorted_indices]\n    \n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]