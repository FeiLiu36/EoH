[
     {
          "algorithm": "New Algorithm:\n\nThe new algorithm calculates the scores for the bins based on a combination of penalty factors that consider the remaining capacity, the ratio of the item size to the remaining capacity, and the number of items already assigned to each bin. The scores are then adjusted and normalized to fall within the range [0, 1].\n\nStep 1: Calculate the remaining capacity of the bins.\nStep 2: Calculate the first penalty factor that takes into account the remaining capacity and the maximum capacity, giving more weight to bins with larger remaining capacities.\nStep 3: Calculate the second penalty factor that penalizes bins with insufficient capacity for the item.\nStep 4: Calculate the third penalty factor based on the number of items already assigned to each bin.\nStep 5: Calculate the ratio of the item size to the remaining capacity.\nStep 6: Assign scores to the bins based on the product of the penalty factors and the ratio.\nStep 7: Normalize the scores to fall within the range [0, 1].\nStep 8: Return the scores.\n\nModified Algorithm:\n\nThe modified algorithm calculates the scores for the bins based on a combination of a penalty factor that considers the remaining capacity and a weight factor that adjusts the penalty based on the item size. The scores are then adjusted and normalized to fall within the range [0, 1].\n\nStep 1: Calculate the remaining capacity of the bins.\nStep 2: Calculate the penalty factor that penalizes bins based on the remaining capacity, giving more weight to bins with larger remaining capacities.\nStep 3: Calculate the weight factor that adjusts the penalty based on the ratio of the item size to the remaining capacity.\nStep 4: Assign scores to the bins based on the product of the penalty factor and the weight factor.\nStep 5: Normalize the scores to fall within the range [0, 1].\nStep 6: Return the scores.\n\nCode:\n\n```\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Step 1: Calculate the remaining capacity of the bins\n    remaining_capacity = bins - item\n    \n    # Step 2: Calculate the penalty factor that penalizes bins based on the remaining capacity, giving more weight to bins with larger remaining capacities\n    penalty_factor = np.power(remaining_capacity, 2) / np.power(bins, 2)\n    \n    # Step 3: Calculate the weight factor that adjusts the penalty based on the ratio of the item size to the remaining capacity\n    weight_factor = np.where(remaining_capacity >= 0, item / remaining_capacity, 0)\n    \n    # Step 4: Assign scores to the bins based on the product of the penalty factor and the weight factor\n    scores = penalty_factor * weight_factor\n    \n    # Step 5: Normalize the scores to fall within the range [0, 1]\n    min_score = np.min(scores)\n    max_score = np.max(scores)\n    normalized_scores = (scores - min_score) / (max_score - min_score)\n    \n    # Step 6: Return the scores\n    return scores",
          "objective": 0.0156,
          "other_inf": null
     }
]