[
     {
          "algorithm": "New algorithm description: The modified algorithm calculates a score for each bin based on the percentage of remaining capacity to the maximum capacity, the deviation of the remaining capacity from the average capacity, and the squared difference between the remaining capacity and the maximum capacity. The algorithm then sorts the bins based on their scores, and the item is assigned to the bin with the maximum score. If two or more bins have the same maximum score, the bin with the smallest remaining capacity is chosen. Additionally, the modified algorithm penalizes bins that are already close to their maximum capacity to encourage using bins with more available space.\n\nCode:\n\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    avg_capacity = np.mean(bins)\n    max_capacity = np.max(bins)\n    \n    percentage_weight = 0.8\n    deviation_weight = 0.6\n    squared_difference_weight = 0.4\n    close_to_max_penalty = 0.2  # New penalty weight for bins close to their maximum capacity\n    \n    # Calculate scores based on the same formula as before\n    percentage_score = (remaining_capacity / max_capacity) * percentage_weight\n    deviation_score = np.abs(remaining_capacity - avg_capacity) * deviation_weight\n    squared_difference_score = np.square(remaining_capacity - max_capacity) * squared_difference_weight\n    \n    # Apply penalty for bins close to their maximum capacity\n    penalty_score = np.where(remaining_capacity > (max_capacity * 0.8), -close_to_max_penalty * max_capacity, 0)\n    \n    scores = percentage_score + deviation_score + squared_difference_score + penalty_score\n    \n    sorted_indices = np.argsort(scores)[::-1]\n    sorted_bins = bins[sorted_indices]\n    \n    assigned_bins = np.where(sorted_bins >= item, sorted_bins, np.inf)\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]