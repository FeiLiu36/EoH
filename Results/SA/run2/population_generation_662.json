[
     {
          "algorithm": "New Algorithm Description: The new algorithm scores the bins based on their rest capacity and the item size, penalizes bins with rest capacities less than or equal to the item size, adjusts the scores to ensure self-consistency, and assigns bonus scores based on the square root of the inverse of the rest capacity of each bin, with a weighting factor to control the contribution of bonus scores.\n\nCode:\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    scaling_factor = 0.5\n    bonus_weight = 0.2\n\n    # Calculate the difference between the rest capacity and the item size\n    capacity_diff = bins - item\n\n    # Penalize bins with rest capacities less than or equal to the item size\n    capacity_diff[capacity_diff <= 0] = item\n\n    # Calculate the combined score by multiplying the capacity difference with the scaling factor\n    combined_score = scaling_factor * np.abs(capacity_diff)\n\n    # Adjust the scores using the combined score\n    adjusted_scores = 1 / combined_score\n\n    # Normalize the adjusted scores to ensure self-consistency\n    normalized_scores = adjusted_scores / np.sum(adjusted_scores)\n\n    # Calculate the square root of the inverse of the rest capacity of each bin and assign bonus scores\n    inverse_capacity = 1 / bins\n    square_root_inverse_capacity = np.sqrt(inverse_capacity)\n    bonus_scores = bonus_weight * square_root_inverse_capacity\n\n    # Normalize the bonus scores to ensure self-consistency\n    normalized_bonus_scores = bonus_scores / np.sum(bonus_scores)\n\n    # Combine the normalized scores and normalized bonus scores\n    scores = normalized_scores + normalized_bonus_scores\n\n    return scores",
          "objective": 0.04829,
          "other_inf": null
     }
]