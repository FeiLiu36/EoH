[
     {
          "algorithm": "New algorithm description: The new algorithm calculates the scores for the bins based on the ratio of the sum of the rest capacities to the maximum capacity, penalizes bins with rest capacities less than a certain fraction of the maximum capacity, adjusts the scores based on the item size and the difference between the rest capacity and the item size, normalizes the scores to ensure self-consistency, and then updates the scores based on the item size and the ratio of the sum of rest capacities to the maximum capacity.\n\nCode:\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_rest_capacity = np.max(bins)\n    max_capacity = np.max([item, max_rest_capacity])\n\n    # Calculate the penalty fraction dynamically based on the maximum capacity\n    penalty_fraction = max_rest_capacity / max_capacity\n\n    # Calculate the ratio of the sum of rest capacities to the maximum capacity\n    total_rest_capacity_ratio = np.sum(bins) / max_capacity\n\n    # Penalize bins with rest capacities less than a fraction of the maximum capacity by reducing their scores to zero\n    bins[bins <= penalty_fraction * max_capacity] = 0\n\n    # Calculate the adjusted scores based on the difference between the rest capacity and the item size\n    adjusted_scores = bins - item\n    adjusted_scores[bins + item > max_capacity] = 0\n\n    # Combine the ratio scores and the adjusted scores\n    scores = total_rest_capacity_ratio * adjusted_scores\n\n    # Normalize the final scores to ensure self-consistency\n    scores /= np.sum(scores)\n\n    # Update the scores based on the item size and the ratio of the sum of rest capacities to the maximum capacity\n    scores += item * total_rest_capacity_ratio\n\n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]