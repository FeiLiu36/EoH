[
     {
          "algorithm": "The new algorithm assigns scores to the bins based on a combination of the square root of the item size ratio to the rest capacity, the natural logarithm of the rest capacity, and a penalty factor based on the difference between the maximum capacity and the rest capacity of each bin. The final scores are normalized to ensure self-consistency.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_rest_capacity = np.max(bins)\n    max_capacity = np.max([item, max_rest_capacity])\n\n    # Calculate the penalty fraction dynamically based on the maximum capacity\n    penalty_fraction = (max_capacity - bins) / max_capacity\n\n    # Calculate the adjusted scores based on the square root of the item size ratio to the rest capacity,\n    # the natural logarithm of the rest capacity, and the penalty factor\n    ratio = np.sqrt(item / bins)\n    log_bins = np.log(bins)\n    adjusted_scores = ratio * log_bins * penalty_fraction\n\n    # Normalize the adjusted scores to ensure self-consistency\n    scores = adjusted_scores / np.sum(adjusted_scores)\n\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]