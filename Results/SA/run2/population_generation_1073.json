[
     {
          "algorithm": "New Algorithm Description:\n\nThe new algorithm calculates a score for each bin based on the bin's remaining capacity relative to the item size and the bin's maximum capacity. The algorithm then assigns the item to the bin with the maximum score. If multiple bins have the same maximum score, the bin with the minimum remaining capacity is chosen. If a bin's remaining capacity is exactly equal to the maximum capacity, it will not be considered for assignment and will be given a score of -1. The modified algorithm improves efficiency by avoiding unnecessary calculations and using numpy functions to optimize performance.\n\nCode:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    max_capacity = np.max(bins)\n\n    scores = np.zeros_like(bins)\n    \n    # Calculate scores for bins with remaining capacity\n    nonzero_indices = remaining_capacity > 0\n    scores[nonzero_indices] = 1 / remaining_capacity[nonzero_indices]\n    \n    # Set score of bins with capacity equal to maximum capacity to -1\n    scores[remaining_capacity == max_capacity] = -1\n    \n    # Find the bin with the maximum score\n    max_score = np.max(scores)\n    \n    # Find the indices of bins with the maximum score\n    max_score_indices = np.where(scores == max_score)[0]\n    \n    # Find the minimum remaining capacity among bins with the maximum score\n    min_remaining_capacity = np.min(remaining_capacity[max_score_indices])\n\n    # Reset scores of bins that do not have the minimum remaining capacity\n    scores[remaining_capacity != min_remaining_capacity] = 0\n    \n    return scores",
          "objective": 0.04457,
          "other_inf": null
     }
]