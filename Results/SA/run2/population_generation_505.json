[
     {
          "algorithm": "My new algorithm is a modification of the provided algorithm. It assigns items to bins based on a combination of factors including the ratio of remaining capacity to item size, a penalty term for bins that have a remaining capacity less than a certain threshold, a penalty for bins that already have higher items assigned, and a bonus for bins that have a remaining capacity close to their maximum capacity. However, the weight calculation for the ratio of remaining capacity to item size is modified to incorporate a different non-linear transformation.\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    \n    # Calculate weights based on a different non-linear transformation of the ratio of remaining capacity to item size\n    weights = np.exp(-(remaining_capacity / item) ** 3) # Modified non-linear transformation\n    \n    # Normalize weights within [0, 1] to maintain self-consistency\n    weights = weights / np.sum(weights)\n    \n    # Penalty for bins with remaining capacity less than 20% of maximum capacity\n    near_full_capacity_penalty = np.where(remaining_capacity < (np.max(bins) * 0.2), np.max(bins), 0)\n    \n    # Calculate the ratio of item size to bin capacity and penalize higher ratios\n    ratio_penalty = np.where(bins != 0, np.power(item / bins, 2), 0)\n    \n    # Penalty for bins that already have higher items assigned\n    higher_item_penalty = np.where(bins < item, 0.25 * item, 0)\n    \n    # Bonus for bins with remaining capacity close to their maximum capacity\n    near_max_capacity_bonus = np.where(remaining_capacity == (np.max(bins) * 0.8), 0.1 * np.max(bins), 0)\n    \n    scores = weights + near_full_capacity_penalty + ratio_penalty - higher_item_penalty - near_max_capacity_bonus\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]