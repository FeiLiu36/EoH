[
     {
          "algorithm": "The new algorithm assigns scores to the bins based on the inverse of the log values of the rest capacity of each bin, a penalty factor that accounts for the cube of the ratio of the item size to the rest capacity of each bin divided by the maximum item size, a scaling factor that considers the square of the difference between the rest capacity and the maximum capacity, and an additional factor that penalizes low rest capacities to promote better bin utilization. The final scores are adjusted to ensure self-consistency by normalizing them to the sum of the adjusted scores, and the output scores are sorted in descending order.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate the inverse of the log values of the rest capacity of each bin\n    inv_bins = 1 / np.log(bins)\n    \n    # Calculate the cube of the ratio of the item size to the rest capacities of each bin\n    ratio = item / bins\n    ratio_cube = np.power(ratio, 3)\n    \n    # Calculate the penalty factor based on the cube ratio divided by the maximum item size\n    penalty_factor = ratio_cube / np.max(ratio_cube)\n    \n    # Calculate the square of the difference between the rest capacity and the maximum capacity\n    max_capacity = np.max(bins)\n    difference = max_capacity - bins\n    difference_square = np.square(difference)\n    \n    # Calculate the scaling factor based on the difference square\n    scaling_factor = np.square(difference) / np.max(np.square(difference))\n    \n    # Calculate an additional factor to penalize low rest capacities\n    low_capacity_penalty = np.exp(-inv_bins)\n    \n    # Calculate the adjusted scores based on the inverse of the bins, the penalty factor, the scaling factor, and the low capacity penalty\n    adjusted_scores = inv_bins * penalty_factor * scaling_factor * low_capacity_penalty\n    \n    # Normalize the adjusted scores to ensure self-consistency\n    scores = adjusted_scores / np.sum(adjusted_scores)\n    \n    # Sort the scores in descending order\n    scores = np.sort(scores)[::-1]\n    \n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]