[
     {
          "algorithm": "\nThe new algorithm calculates the score for each bin by dividing the remaining capacity of the bin by the item size, then subtracting the penalty factor based on the difference between the remaining capacity and the item size. The scores are then multiplied by a weight based on the ratio of the item size to the remaining capacity, and finally, the scores are normalized to ensure consistency and comparability across different bins. The score calculation takes into account the square of the remaining capacity and the square of the item size, ensuring that larger differences are penalized more. In addition, the algorithm ensures that bins with maximum capacity are not used, minimizing the number of used bins.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    difference_capacity = remaining_capacity - item\n    \n    scores = (remaining_capacity / item) - difference_capacity\n    \n    weight = item / remaining_capacity\n    scores *= weight\n    \n    normalized_scores = (scores - np.min(scores)) / (np.max(scores) - np.min(scores))\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]