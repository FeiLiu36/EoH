[
     {
          "algorithm": "New algorithm:\nThe new algorithm calculates the potential additional capacity of each bin if the current item is assigned to it. It then assigns scores to the bins based on the potential additional capacity, the item size, and a penalty factor for bins that are close to their maximum capacity. The scores are then normalized to ensure self-consistency. Additionally, the new algorithm introduces a scaling factor to adjust the weight of the potential capacity and penalty factors, providing more flexibility in the scoring process.\n\nCode:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    num_bins = len(bins)\n    weight = 0.5  # Set weight value\n    penalty_factor = 0.1  # Set penalty factor value\n    scaling_factor = 2.0  # Set scaling factor value\n    \n    # Calculate the potential additional capacity of each bin if the item is assigned to it\n    potential_capacity = bins - item\n    \n    # Apply the weight parameter to the potential additional capacity\n    weighted_potential_capacity = weight * np.exp(-potential_capacity)  # Apply exponential decay to the weighted potential capacity\n    \n    # Compute the penalty factors for bins that are close to their maximum capacity\n    penalty_capacity = np.maximum(bins, 1) / np.maximum(potential_capacity, 1)  # Used np.maximum to avoid division by zero\n    weighted_penalty_capacity = penalty_factor * penalty_capacity\n    \n    # Calculate the modified scores based on the weighted potential capacity, penalty factors, and scaling factor\n    raw_scores = (weighted_potential_capacity - weighted_penalty_capacity) * scaling_factor\n    \n    # Normalize the scores to ensure self-consistency\n    scores = raw_scores / np.sum(raw_scores)\n\n    return scores",
          "objective": 0.04306,
          "other_inf": null
     }
]