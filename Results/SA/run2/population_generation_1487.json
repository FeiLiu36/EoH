[
     {
          "algorithm": "The new algorithm computes the scores for each bin based on the reciprocal of the absolute difference between the rest capacity of each bin and the item size, the square root of the sum of the rest capacities of all the bins, and the exponential of the difference between the rest capacity of each bin and the maximum capacity among all bins. The scores for each component are multiplied by a set of weights, determined by the proportion of the modified scores contributed by each component in the original algorithm. These scores are then adjusted with weighted components by dividing each score by one plus the exponential of the difference between the rest capacity of each bin and the mean of all the bin capacities. Finally, the adjusted scores are normalized by dividing each score by the sum of all adjusted scores plus the number of bins.\n\nHere's the implementation of the new score algorithm:\n\n```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    reciprocal_diff = 1 / np.abs(bins - item)\n    sqrt_sum_rest_capacities = np.sqrt(np.sum(bins))\n    exp_diff = np.exp(bins - np.max(bins))\n  \n    modified_scores = reciprocal_diff * 0.2 + sqrt_sum_rest_capacities * 0.5 + exp_diff * 0.3\n    weights = [np.sum(modified_scores) for _ in range(3)]\n    weights = np.divide(weights, np.sum(modified_scores))\n    \n    # Adjusted scores with weighted components\n    adjusted_scores = (\n        weights[0] * np.divide(reciprocal_diff, (1 + np.exp(bins - np.mean(bins)))) +\n        weights[1] * np.divide(sqrt_sum_rest_capacities, (1 + np.exp(bins - np.mean(bins)))) +\n        weights[2] * np.divide(exp_diff, (1 + np.exp(bins - np.mean(bins))))\n    )\n  \n    sum_modified_scores = np.sum(adjusted_scores)\n    scores = adjusted_scores / (sum_modified_scores + len(bins))\n    \n    return scores",
          "objective": 0.04165,
          "other_inf": null
     }
]