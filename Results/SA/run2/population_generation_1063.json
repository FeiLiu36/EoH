[
     {
          "algorithm": "Algorithm Description (Modified Version):\n\nMy modified algorithm calculates a score for each bin based on the bin's remaining capacity relative to the item size, the bin's maximum capacity, and a penalty term based on the difference between the average capacity and the maximum capacity. The algorithm then assigns the item to the bin with the maximum score. If multiple bins have the same maximum score, the bin with the minimum remaining capacity is chosen.\n\nCode:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    max_capacity = np.max(bins)\n    avg_capacity = np.mean(bins)\n    \n    item_size_ratio = item / remaining_capacity\n    \n    remaining_capacity_score = np.power(item_size_ratio, 2)\n    max_capacity_score = np.power((max_capacity - remaining_capacity) / max_capacity, 2)\n    penalty_score = np.power((avg_capacity - max_capacity) / avg_capacity, 2)\n    \n    scores = remaining_capacity_score + max_capacity_score + penalty_score\n    \n    sorted_indices = np.lexsort((remaining_capacity, -scores))\n    sorted_scores = scores[sorted_indices]\n    \n    assigned_scores = np.where(sorted_scores >= item, sorted_scores, np.inf)\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]