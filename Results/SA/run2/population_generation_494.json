[
     {
          "algorithm": "The new algorithm aims to assign items to bins by calculating the score for each bin based on the remaining capacity, the ratio of remaining capacity to item size, a penalty term for bins that have a remaining capacity less than a certain threshold, and a bonus for bins that have a remaining capacity close to their maximum capacity. Additionally, the new algorithm considers the ratio of item size to bin capacity, where higher ratios are penalized. The algorithm then normalizes the scores to maintain self-consistency and returns the calculated scores for each bin.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    \n    # Calculate weights based on ratio of remaining capacity to item size\n    weights = np.exp(1 / (remaining_capacity / item))\n    normalized_weights = weights / np.sum(weights) # Normalize weights to maintain self-consistency\n    \n    # Penalty for bins with remaining capacity less than 10% of maximum capacity\n    near_full_capacity_penalty = (remaining_capacity < (np.max(bins) * 0.1)) * 0.5 * np.max(bins)\n    \n    # Calculate the ratio of item size to bin capacity and penalize higher ratios\n    ratio_penalty = (item / bins)\n    \n    # Bonus for bins with remaining capacity close to their maximum capacity\n    near_max_capacity_bonus = (remaining_capacity == (np.max(bins) * 0.9)) * 0.2 * np.max(bins)\n    \n    scores = normalized_weights + near_full_capacity_penalty + ratio_penalty - near_max_capacity_bonus\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]