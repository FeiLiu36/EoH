[
     {
          "algorithm": "New algorithm description: The new algorithm assigns scores to bins based on a combination of the remaining capacity, the ratio of remaining capacity to the maximum capacity, the average capacity of the bins, and the standard deviation of the bins. It then calculates a weighted distance score for each bin based on the bin's deviation from the average capacity and adjusts the scores using a priority score.\n\nNew algorithm implementation:\n\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    max_capacity = np.max(bins)\n    avg_capacity = np.mean(bins)\n    std_capacity = np.std(bins)\n    \n    weights = np.exp(-(bins - avg_capacity))\n    capacity_ratio = remaining_capacity / max_capacity\n   \n    distance_score = np.abs(remaining_capacity - avg_capacity)\n    weighted_distance_score = distance_score * weights\n    priority_scores = np.array([0.5, 0.3, 0.2])  # Example priority scores for bins, can be customized\n    \n    scores = (np.exp(-((bins - avg_capacity) / max_capacity + 0.5) / (1 - capacity_ratio))\n              * priority_scores[:, np.newaxis] * weighted_distance_score)\n    \n    std_inverse = 1 / std_capacity\n    scaled_scores = scores * std_inverse\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]