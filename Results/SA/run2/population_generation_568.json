[
     {
          "algorithm": "My new algorithm modifies the existing algorithm by introducing a penalty for bins with a larger remaining capacity, provides a bonus for bins with a smaller average size of items assigned, and incorporates a penalty for bins with a higher utilization rate, while still considering the remaining capacity and average size of items assigned to each bin to minimize the number of used bins.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate base scores by subtracting the ratio of the remaining capacity to the item size from 1\n    base_scores = 1 - bins / item\n    \n    # Calculate penalty for bins with higher items assigned based on a linear decreasing penalty rate\n    high_item_penalty = np.maximum(0, (bins - item) / item)\n    \n    # Calculate bonus for bins with a smaller average size of items assigned\n    average_size = (np.sum(bins) - bins) / (len(bins) - 1)\n    tiny_average_bonus = np.maximum(0, (average_size - bins) / average_size)\n    \n    # Calculate penalty for bins with larger remaining capacity\n    remaining_capacity_penalty = np.maximum(0, (bins - item) / bins)\n    \n    # Calculate penalty for bins with a higher utilization rate\n    utilization_penalty = np.maximum(0, (1 - bins / np.max(bins)) * np.where((bins >= 0.8 * np.max(bins)), 0.2, 0))\n    \n    # Calculate final scores by combining base scores, high item penalty, average size bonus, remaining capacity penalty, and utilization penalty\n    scores = base_scores - high_item_penalty + tiny_average_bonus - remaining_capacity_penalty - utilization_penalty\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]