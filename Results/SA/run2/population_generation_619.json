[
     {
          "algorithm": "The new algorithm first calculates the potential additional capacity of each bin if the current item is assigned to it. It then assigns scores to the bins based on the potential additional capacity, the item size, and a penalty factor for bins that are close to their maximum capacity. The scores are then normalized to ensure self-consistency.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    num_bins = len(bins)\n    weight = 0.5  # Set weight value\n    penalty_factor = 0.1  # Set penalty factor value\n    \n    # Calculate the potential additional capacity of each bin if the item is assigned to it\n    potential_capacity = bins - item\n    \n    # Apply the weight parameter to the potential additional capacity\n    weighted_potential_capacity = weight * np.exp(-potential_capacity)  # Apply exponential decay to the weighted potential capacity\n    \n    # Compute the penalty factors for bins that are close to their maximum capacity\n    penalty_capacity = np.maximum(bins, 1) / np.maximum(potential_capacity, 1)  # Used np.maximum to avoid division by zero\n    weighted_penalty_capacity = penalty_factor * penalty_capacity\n    \n    # Calculate the modified scores based on the weighted potential capacity and penalty factors\n    scores = (weighted_potential_capacity - weighted_penalty_capacity) / np.sum(weighted_potential_capacity - weighted_penalty_capacity)\n\n    return scores",
          "objective": 0.04306,
          "other_inf": null
     }
]