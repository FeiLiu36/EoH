[
     {
          "algorithm": "New algorithm description: The new algorithm calculates the scores for the bins based on the ratio of the sum of the rest capacities to the maximum capacity, penalizes bins with rest capacities less than a certain fraction of the maximum capacity, and gives a bonus score to bins with rest capacities greater than a certain threshold value. The final scores are then normalized to ensure self-consistency. Additionally, the algorithm introduces a weighting factor to balance the effect of the penalty and bonus scores, which is dynamically calculated based on the maximum capacity of the bins, the item size, and a user-defined parameter.\n\nNew algorithm implementation:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_rest_capacity = np.max(bins)\n    max_capacity = np.max([item, max_rest_capacity])\n\n    # Calculate the penalty fraction dynamically based on the maximum capacity\n    penalty_fraction = max_rest_capacity / max_capacity\n\n    # Calculate the bonus threshold dynamically based on the maximum rest capacity\n    bonus_threshold = max_rest_capacity\n\n    # Calculate the weighting factor dynamically based on the penalty fraction, item size, and a user-defined parameter\n    parameter = 0.5  # User-defined parameter\n    weighting_factor = max_capacity / (max_capacity - parameter * penalty_fraction * item)\n\n    # Calculate the ratio of the sum of rest capacities to the maximum capacity\n    total_rest_capacity_ratio = np.sum(bins) / max_capacity\n\n    # Penalize bins with rest capacities less than a fraction of the maximum capacity by reducing their scores to zero\n    bins[bins <= penalty_fraction * max_capacity] = 0\n\n    # Calculate the adjusted scores by multiplying the bins with the weighting factor and total rest capacity ratio\n    adjusted_scores = bins * weighting_factor * total_rest_capacity_ratio\n\n    # Assign bonus scores based on the rest capacity of each bin\n    bonus_scores = np.where(bins > bonus_threshold, bins - item, 0)\n\n    # Combine the adjusted scores and bonus scores\n    scores = adjusted_scores + bonus_scores\n\n    # Normalize the final scores to ensure self-consistency\n    scores /= np.sum(scores)\n\n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]