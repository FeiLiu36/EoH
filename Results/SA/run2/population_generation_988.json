[
     {
          "algorithm": "The new algorithm assigns scores to bins based on the remaining capacity, ratio of remaining capacity to the maximum capacity, and the average capacity of the bins. It then calculates a weighted distance score for each bin based on the bin's deviation from the average capacity and uses priority scores to further adjust the scores. The final scores are scaled and penalized based on the deviation from the median capacity of the bins.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    max_capacity = np.max(bins)\n    avg_capacity = np.mean(bins)\n    \n    weights = np.exp(-(bins - avg_capacity))\n    capacity_ratio = remaining_capacity / max_capacity\n    \n    distance_score = np.abs(remaining_capacity - avg_capacity)\n    weighted_distance_score = distance_score * weights\n    priority_scores = np.array([0.5, 0.3, 0.2])  # Example priority scores for bins, can be customized\n    \n    priority_based_scores = priority_scores[:, np.newaxis] * weights\n    \n    scores = (np.exp(-((bins - avg_capacity) / max_capacity + 0.5) / (1 - capacity_ratio))\n              * priority_based_scores * weighted_distance_score)\n    \n    median_score = np.median(scores)\n    scaled_scores = scores / median_score\n    \n    penalty_term = np.abs(bins - np.median(bins))\n    scaled_scores -= penalty_term / np.max(penalty_term)\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]