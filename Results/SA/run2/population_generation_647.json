[
     {
          "algorithm": "New Algorithm Description: The new algorithm assigns scores to the bins based on their rest capacities raised to the power of a scaling factor, adjusts the scores based on the item-size ratio, and normalizes the scores to ensure self-consistency. It then calculates the cumulative sum of the adjusted scores, calculates the difference between the cumulative sums and the maximum cumulative sum, and finally assigns bonus scores to the bins based on the inverse of the differences.\n\nNew Algorithm Code:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    scaling_factor = 0.7\n\n    # Adjust the scores by raising the rest capacities to the power of the scaling factor\n    adjusted_scores = bins ** scaling_factor\n\n    # Calculate the item-size ratio\n    size_ratio = item / bins\n\n    # Adjust the scores by multiplying with the item-size ratio\n    adjusted_scores *= size_ratio\n\n    # Normalize the adjusted scores to ensure self-consistency\n    normalized_scores = adjusted_scores / np.sum(adjusted_scores)\n\n    # Calculate the cumulative sum of the adjusted scores\n    cumulative_sum = np.cumsum(normalized_scores)\n\n    # Calculate the difference between the cumulative sums and the maximum cumulative sum\n    differences = np.max(cumulative_sum) - cumulative_sum\n\n    # Assign bonus scores based on the inverse of the differences\n    bonus_scores = 1 / differences\n\n    # Normalize the bonus scores to ensure self-consistency\n    normalized_bonus_scores = bonus_scores / np.sum(bonus_scores)\n\n    # Combine the normalized scores and normalized bonus scores\n    scores = normalized_scores + normalized_bonus_scores\n\n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]