[
     {
          "algorithm": "My new algorithm assigns scores to the bins based on the product of the rest capacities and the ratio of the item size to the maximum capacity, penalizes bins with rest capacities less than a fixed fraction of the maximum capacity, and adjusts the scores based on the difference between the rest capacity and the item size, considering the logarithm of the item size and the ratio of the item size to the maximum capacity.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_rest_capacity = np.max(bins)\n    max_capacity = np.max([item, max_rest_capacity])\n\n    # Calculate the penalty fraction dynamically based on the maximum capacity\n    penalty_fraction = max_rest_capacity / max_capacity\n\n    # Calculate the normalized ratio of the rest capacities to the maximum capacity\n    rest_capacity_ratio = bins / max_capacity\n\n    # Calculate the adjusted scores based on the difference between the rest capacity and the item size\n    adjusted_scores = bins - item\n    adjusted_scores[adjusted_scores < 0] = 0\n\n    # Create a new array of scores\n    scores = np.zeros(len(bins))\n\n    # Iterate through each bin\n    for i in range(len(bins)):\n        # If the rest capacity of the bin is less than the penalty fraction of the maximum capacity,\n        # assign a score of zero\n        if bins[i] <= penalty_fraction * max_capacity:\n            scores[i] = 0\n        else:\n            # Calculate the score based on the product of the rest capacities, the logarithm of the item size,\n            # and the ratio of the item size to the maximum capacity\n            scores[i] = rest_capacity_ratio[i] * np.log(item) * (item / max_capacity)\n\n    # Normalize the final scores to ensure self-consistency\n    scores /= np.sum(scores)\n\n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]