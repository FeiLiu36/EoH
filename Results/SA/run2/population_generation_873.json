[
     {
          "algorithm": "New algorithm description: \nThe new algorithm calculates the score for each bin based on a combination of factors including the penalty factor, the proximity factor, and a factor that considers the ratio of the item size to the remaining capacity of the bin, while also taking into account the maximum capacity of each bin. Additionally, the algorithm introduces a diversity factor that promotes distributing items across different bins evenly by calculating the standard deviation of the remaining capacities among the bins and assigning higher scores to bins with higher standard deviations. The algorithm also includes a weight factor that can be adjusted to prioritize certain factors over others. The scores are calculated using a modified formula that combines all these factors.\n\nCode:\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray, weight_factor: float = 1) -> np.ndarray:\n    num_bins = len(bins)\n    \n    # Calculate the penalty factor for bins nearing their maximum capacity\n    penalty_factor = np.where(bins >= 0.9 * np.max(bins), -np.inf, 1)\n    \n    # Calculate the proximity factor based on the difference between each bin's capacity and the mean capacity\n    proximity_factor = np.exp(-np.abs(bins - np.mean(bins)))\n    \n    # Calculate the ratio factor based on the item size and remaining capacity of each bin\n    ratio_factor = np.where(bins > item, item / bins, np.inf)\n    \n    # Calculate the diversity factor based on the standard deviation of remaining capacities among bins\n    diversity_factor = np.std(bins)\n    \n    # Calculate the scores based on the modified formula and weight factor\n    scores = weight_factor * (penalty_factor * proximity_factor * ratio_factor * diversity_factor)\n    \n    return scores",
          "objective": 0.03874,
          "other_inf": null
     }
]