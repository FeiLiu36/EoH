[
     {
          "algorithm": "New algorithm description: The new algorithm calculates the scores for the bins based on the ratio of the sum of the rest capacities to the maximum capacity, penalizes bins with rest capacities less than a certain fraction of the maximum capacity, and allows for a variable bonus score based on the rest capacity of each bin. The final scores are then normalized to ensure self-consistency.\n\nNew algorithm implementation:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_rest_capacity = np.max(bins)\n    max_capacity = np.max([item, max_rest_capacity])\n\n    # Calculate the penalty fraction dynamically based on the maximum capacity\n    penalty_fraction = max_rest_capacity / max_capacity\n\n    # Calculate the ratio of the sum of rest capacities to the maximum capacity\n    total_rest_capacity_ratio = np.sum(bins) / max_capacity\n\n    # Penalize bins with rest capacities less than a fraction of the maximum capacity by reducing their scores to zero\n    bins[bins <= penalty_fraction * max_capacity] = 0\n\n    # Calculate the bonus scores based on the rest capacity of each bin\n    bonus_scores = bins - item\n\n    # Set bonus scores to zero for bins that would exceed their maximum capacity if the item was assigned to them\n    bonus_scores[bins + item > max_capacity] = 0\n\n    # Combine the adjusted scores and bonus scores\n    scores = bins * total_rest_capacity_ratio + bonus_scores\n\n    # Normalize the final scores to ensure self-consistency\n    scores /= np.sum(scores)\n\n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]