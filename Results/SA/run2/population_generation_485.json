[
     {
          "algorithm": "New algorithm description: The modified algorithm calculates the score for each bin based on the ratio of the remaining capacity to the item size, with higher weights assigned to bins with lower remaining capacity. Additionally, the algorithm introduces a penalty term for bins that have a remaining capacity less than a certain threshold, to encourage assigning items to bins that are not close to full capacity. The algorithm also includes a term that penalizes bins with remaining capacity equal to the maximum capacity, to further discourage using bins that are at full capacity.\n\nNew algorithm in Python:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    \n    weights = 1 / (remaining_capacity / item)\n    normalized_weights = weights / np.sum(weights) # Normalize weights to maintain self-consistency\n    \n    max_capacity_penalty = (remaining_capacity == np.max(bins)) * np.max(bins) \n    \n    near_full_capacity_penalty = (remaining_capacity < (np.max(bins) * 0.2)) * 0.2 * np.max(bins)\n    \n    scores = normalized_weights + max_capacity_penalty + near_full_capacity_penalty\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]