[
     {
          "algorithm": "New algorithm description: The new algorithm assigns a score to each bin based on its remaining capacity and the item size, while also penalizing bins that cannot accommodate the item. The main steps are as follows:\n\n1. Find the maximum remaining capacity among the bins.\n2. Calculate a priority factor for each bin by dividing the remaining capacity by the item size.\n3. Initialize an array of scores with zeros.\n4. For each bin:\n   a. If the remaining capacity is less than the item size:\n      - Set the score for that bin to -inf to indicate that it cannot accommodate the item.\n   b. If the bin can accommodate the item:\n      - Calculate the score by multiplying the priority factor by the ratio of item size to remaining capacity, and subtracting the square root of the remaining capacity.\n   c. If the remaining capacity is equal to the maximum remaining capacity:\n      - Set the score for that bin to -inf to exclude it from being used.\n5. Multiply the scores by 1 for bins that can accommodate the item and by infinity for bins that cannot.\n6. Return the resulting scores array.\n\nCode:\n\n",
          "code": "import numpy as np\nimport math\n\ndef score(item, bins):\n    max_remaining_capacity = np.max(bins)\n    priority_factor = bins / item\n\n    low_capacity_bins = bins < item\n\n    scores = np.zeros(len(bins), dtype=np.float64)\n    scores[low_capacity_bins] = -np.inf\n    scores[bins == max_remaining_capacity] = -np.inf\n    scores[~(low_capacity_bins | (bins == max_remaining_capacity))] = priority_factor[~(low_capacity_bins | (bins == max_remaining_capacity))] * (item / bins[~(low_capacity_bins | (bins == max_remaining_capacity))]) - np.sqrt(bins[~(low_capacity_bins | (bins == max_remaining_capacity))])\n\n    scores = scores * (1 - (low_capacity_bins | (bins == max_remaining_capacity))) + (low_capacity_bins | (bins == max_remaining_capacity)) * np.inf\n\n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]