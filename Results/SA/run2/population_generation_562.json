[
     {
          "algorithm": "My new algorithm calculates the score for each bin based on the remaining capacity, penalizes bins with higher items assigned, introduces a penalty for bins with remaining capacity close to their maximum, and provides a bonus for bins with a large remaining capacity. This algorithm aims to minimize the number of used bins.\n\nHere's the modified version of the algorithm:\n\n```\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate weighted base scores by subtracting the ratio of the remaining capacity to the item size from 1\n    base_scores = 1 - bins / item\n    \n    # Calculate penalty for bins with higher items assigned based on a linear decreasing penalty rate\n    high_item_penalty = np.maximum(0, (bins - item) / item)\n    \n    # Calculate penalty for bins with remaining capacity close to their maximum capacity with an increasing penalty rate\n    near_max_capacity_penalty = np.maximum(0, (1 - bins / np.max(bins)) * np.where((bins >= 0.8 * np.max(bins)), 0.2, 0))\n    \n    # Calculate bonus for bins with a large remaining capacity with an increasing bonus rate\n    large_capacity_bonus = np.maximum(0, (bins - item * 1.2) / item * np.where((bins > item * 1.2), 0.2, 0))\n\n    # Calculate final scores by combining weighted base scores, high item penalty, near-maximum capacity penalty, and large capacity bonus\n    scores = base_scores - high_item_penalty - near_max_capacity_penalty + large_capacity_bonus\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]