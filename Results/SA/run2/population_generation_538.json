[
     {
          "algorithm": "\nThe new algorithm calculates the scores for the bins based on the difference between the remaining capacity and the item size, penalizes bins with higher items assigned, and provides a bonus for bins with a large remaining capacity. It also takes into account the proportion of remaining capacity to the maximum capacity of each bin, introduces a penalty for bins with remaining capacity close to their maximum capacity, and penalizes bins with lower remaining capacity in proportion to the item size squared. The algorithm combines all these features to calculate the final scores for the bins.\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate base scores by subtracting remaining capacity from item size\n    base_scores = item - bins\n    \n    # Calculate bonus for bins with a large remaining capacity\n    large_capacity_bonus = np.where(bins > (1.2 * item), 0.2 * item, 0)\n    \n    # Calculate proportion of remaining capacity to maximum capacity\n    proportions = bins / np.max(bins)\n    \n    # Calculate penalty for bins with remaining capacity close to their maximum capacity\n    near_max_capacity_penalty = np.where(proportions >= 0.8, 0.1 * item, 0)\n    \n    # Calculate penalty for bins with lower remaining capacity in proportion to the item size squared\n    low_capacity_penalty = np.where(bins < 0.5 * item, 0.2 * np.square(item), 0)\n\n    # Calculate final scores by combining base scores, large capacity bonus, near-maximum capacity penalty, and low capacity penalty\n    scores = base_scores + large_capacity_bonus - near_max_capacity_penalty - low_capacity_penalty\n    \n    return scores",
          "objective": 0.04065,
          "other_inf": null
     }
]