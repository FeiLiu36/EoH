[
     {
          "algorithm": "New algorithm description: \nThe new algorithm calculates the scores for the bins based on their rest capacity and the item size, and adjusts the scores to ensure self-consistency. It penalizes bins with rest capacities less than a fraction of the item size, and assigns bonus scores based on the inverse of the rest capacity of each bin. Additionally, it considers the floor division of the rest capacity divided by the item size to differentiate between bins with the same rest capacity but different utilization levels. The algorithm also introduces a decay factor that reduces the bonus scores based on the bin utilization levels to promote the utilization of bins with higher rest capacity.\n\nCode:\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    scaling_factor = 0.5\n    penalty_fraction = 0.8\n    decay_factor = 0.9\n    \n    # Calculate the floor division of rest capacity divided by item size\n    utilization_levels = np.floor_divide(bins, item)\n    \n    # Calculate the difference between the rest capacity and the penalty fraction of the item size\n    capacity_diff = bins - penalty_fraction * item\n\n    # Penalize bins with rest capacities less than a fraction of the item size\n    capacity_diff[capacity_diff <= 0] = -scaling_factor * penalty_fraction * item\n\n    # Adjust the scores using the capacity difference\n    adjusted_scores = scaling_factor * capacity_diff\n\n    # Normalize the adjusted scores to ensure self-consistency\n    normalized_scores = adjusted_scores / np.sum(adjusted_scores)\n\n    # Assign bonus scores based on the inverse of the rest capacity of each bin\n    bonus_scores = 1 / bins\n\n    # Decay the bonus scores based on the bin utilization levels\n    decayed_bonus_scores = bonus_scores * (decay_factor ** utilization_levels)\n\n    # Normalize the decayed bonus scores to ensure self-consistency\n    normalized_bonus_scores = decayed_bonus_scores / np.sum(decayed_bonus_scores)\n\n    # Combine the normalized scores and normalized bonus scores, considering utilization levels\n    scores = normalized_scores + normalized_bonus_scores * (1/utilization_levels)\n    \n    # Normalize the final scores to ensure self-consistency\n    scores /= np.sum(scores)\n\n    return scores",
          "objective": 0.03854,
          "other_inf": null
     }
]