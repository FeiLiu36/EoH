[
     {
          "algorithm": "The new algorithm assigns scores to the bins based on the ratio of the logarithm of the item size to the logarithm of the rest capacity, the cube root of the rest capacity, and a penalty factor based on the difference between the maximum capacity and the rest capacity of each bin. The final scores are normalized to ensure self-consistency.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_rest_capacity = np.max(bins)\n    max_capacity = np.max([item, max_rest_capacity])\n\n    # Calculate the penalty fraction dynamically based on the maximum capacity\n    penalty_fraction = (max_capacity - bins) / max_capacity\n\n    # Calculate the adjusted scores based on the ratio of the logarithm of the item size to the logarithm of the rest capacity,\n    # the cube root of the rest capacity, and the penalty factor\n    log_item = np.log(item)\n    log_bins = np.log(bins)\n    adjusted_scores = (log_item / log_bins) * np.cbrt(bins) * penalty_fraction\n\n    # Normalize the adjusted scores to ensure self-consistency\n    scores = adjusted_scores / np.sum(adjusted_scores)\n\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]