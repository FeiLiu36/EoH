[
     {
          "algorithm": "New Algorithm Description: Create a modified version of the algorithm that assigns a score to each bin based on the remaining capacities of the bins, the ratio of the item size to the remaining capacity of each bin, the sum of the remaining capacities of the bins, the logarithm of the sum of the remaining capacities, and the maximum remaining capacity. The score for each bin is then multiplied by a weighting factor based on the difference between the maximum remaining capacity and the remaining capacity of each bin, and the logarithm of the maximum remaining capacity. Finally, the scores are sorted in descending order.\n\nNew Algorithm Code:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray, ratio_weight=1, sum_weight=1, log_sum_weight=1, max_capacity_weight=1, diff_weight=1, log_max_weight=1) -> np.ndarray:\n    remaining_capacity = bins - item\n    max_capacity = np.max(bins)\n    ratio_capacity = item / remaining_capacity\n    sum_remaining_capacity = np.sum(remaining_capacity)\n    log_sum_remaining_capacity = np.log(sum_remaining_capacity)\n    max_remaining_capacity = np.max(remaining_capacity)\n\n    diff_capacity = max_remaining_capacity - remaining_capacity\n    max_capacity_log = np.log(max_remaining_capacity)\n\n    weighting_factor = diff_capacity * max_capacity_log\n\n    scores = (\n        ratio_weight * (remaining_capacity * ratio_capacity) +\n        sum_weight * sum_remaining_capacity +\n        log_sum_weight * log_sum_remaining_capacity +\n        max_capacity_weight * max_remaining_capacity +\n        diff_weight * weighting_factor +\n        log_max_weight * max_capacity_log\n    )\n\n    sorted_scores = np.sort(scores)[::-1]\n\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]