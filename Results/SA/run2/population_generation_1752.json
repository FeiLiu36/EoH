[
     {
          "algorithm": "\nThe new algorithm assigns scores to the bins based on their remaining capacity after assigning the item, and penalizes the bins with larger remaining capacities by taking the inverse of their logarithm, while also considering a penalty factor for bins that are not used.\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate the remaining capacities of the bins after assigning the item\n    remaining_capacity = bins - item\n    \n    # Calculate the penalty factor for bins that are not used\n    penalty = np.where(remaining_capacity >= bins, 0.1, 1)\n    \n    # Calculate the modified scores for the bins\n    scores = np.reciprocal(np.log(remaining_capacity+1)) * penalty\n    \n    # Replace NaN values with a large negative value to avoid errors in assignment\n    scores[np.isnan(scores)] = -np.inf\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]