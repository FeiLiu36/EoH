[
     {
          "algorithm": "\\text{score}}\\def\\item{\\text{item}}\\def\\bins{\\text{bins}}\\def\\scores{\\text{scores}}\\def\\max{\\text{max}}\\def\\remaining{\\text{remaining}}\\def\\normalized{\\text{normalized}}\\def\\weights{\\text{weights}}\\def\\sorted{\\text{sorted}}\\def\\argsort{\\text{argsort}}\\def\\ones{\\text{ones}}\\def\\div{\\text{div}}\n\n\\text{Algorithm Description:} \n\n\\text{The new algorithm first calculates the normalized remaining capacity of each bin (after deducting the item size) by dividing it by the maximum capacity of the bins.}\n\n\\text{It then assigns a weight to each bin based on the normalized remaining capacity squared and the remaining capacity of the bin (after item deduction), where bins with a higher score have a higher weight.}\n\n\\text{The weights are used to calculate the scores for each bin by multiplying the normalized remaining capacity squared by the weight of the bin, and the scores are sorted in descending order.}\n\n\\begin{verbatim}\nimport numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_capacity = np.max(bins)\n    remaining_capacity = bins - item\n\n    normalized_capacity = remaining_capacity / max_capacity\n    weights = 1 / (normalized_capacity**2 + remaining_capacity)\n\n    scores = normalized_capacity**2 * weights\n    sorted_indices = np.argsort(scores)[::-1]\n    scores = scores[sorted_indices]\n\n    return scores\n\\end{verbatim",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_capacity = np.max(bins)\n    remaining_capacity = bins - item\n\n    normalized_capacity = remaining_capacity / max_capacity\n    weights = 1 / (normalized_capacity**2 + remaining_capacity)\n\n    scores = normalized_capacity**2 * weights\n    sorted_indices = np.argsort(scores)[::-1]\n    scores = scores[sorted_indices]\n\n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]