[
     {
          "algorithm": "New algorithm description: The new algorithm assigns scores to bins based on the remaining capacity, average capacity, and maximum capacity of the bins. It then calculates a weighted distance score for each bin and uses priority scores to further adjust the scores. The final scores are scaled and penalized based on the deviation from the median capacity of the bins.\n\nHere's the modified code for the `score` function:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    max_capacity = np.max(bins)\n    avg_capacity = np.mean(bins)\n    \n    weights = np.exp(-(bins - avg_capacity))\n    capacity_ratio = remaining_capacity / max_capacity\n    bin_efficiency = remaining_capacity / bins\n    \n    distance_score = np.abs(remaining_capacity - avg_capacity)\n    weighted_distance_score = distance_score * weights\n    priority_scores = np.array([0.5, 0.3, 0.2])  # Example priority scores for bins, can be customized\n    \n    priority_based_scores = priority_scores[:, np.newaxis] * weights\n    \n    scores = (np.exp(-((bins - avg_capacity) / max_capacity + 0.5) / (1 - capacity_ratio))\n              * priority_based_scores * weighted_distance_score) \n    scores -= 0.5 * (bins - avg_capacity) / max_capacity\n    scores -= 0.2 * bin_efficiency\n    \n    median_score = np.median(scores)\n    scaled_scores = scores / median_score\n    \n    penalty_term = np.abs(bins - np.median(bins))\n    scaled_scores -= penalty_term / np.max(penalty_term)\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]