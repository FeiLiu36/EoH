[
     {
          "algorithm": "The new algorithm calculates the scores for the bins based on their rest capacity and the item size, penalizes bins with rest capacities less than or equal to a fraction of the item size, adjusts the scores to ensure self-consistency, and assigns bonus scores based on the logarithm of the inverse of the rest capacity of each bin cubed, with a weighting factor to control the contribution of bonus scores.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    scaling_factor = 0.5\n    penalty_fraction = 0.8\n    bonus_weight = 0.2\n\n    # Calculate the difference between the rest capacity and the penalty fraction of the item size\n    capacity_diff = bins - penalty_fraction * item\n\n    # Penalize bins with rest capacities less than or equal to a fraction of the item size\n    capacity_diff[capacity_diff <= 0] = penalty_fraction * item\n\n    # Calculate the combined score by multiplying the capacity difference with the scaling factor\n    combined_score = scaling_factor * np.abs(capacity_diff)\n\n    # Adjust the scores using the combined score\n    adjusted_scores = 1 / combined_score\n\n    # Normalize the adjusted scores to ensure self-consistency\n    normalized_scores = adjusted_scores / np.sum(adjusted_scores)\n\n    # Calculate the logarithm of the inverse of the rest capacity of each bin cubed and assign bonus scores\n    inverse_capacity = 1 / bins\n    logarithm_inverse_capacity = np.log(inverse_capacity ** 3)\n    bonus_scores = bonus_weight * logarithm_inverse_capacity\n\n    # Normalize the bonus scores to ensure self-consistency\n    normalized_bonus_scores = bonus_scores / np.sum(bonus_scores)\n\n    # Combine the normalized scores and normalized bonus scores\n    scores = normalized_scores + normalized_bonus_scores\n\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]