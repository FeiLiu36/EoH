[
     {
          "algorithm": "New algorithm: The Modified Bin Assignment Algorithm\n1. Initialize an empty array to store the scores for each bin.\n2. Calculate the remaining capacity of each bin by subtracting the item size from the rest capacities of feasible bins.\n3. Compute the maximum capacity and average capacity of all the bins.\n4. Calculate a penalty score for each bin based on the squared difference between its remaining capacity and the average capacity, penalizing large differences.\n5. Calculate a reward score for each bin by subtracting the remaining capacity from the item size multiplied by a weight factor, valuing bins with smaller remaining capacity.\n6. Calculate a priority score for each bin by taking the reciprocal of its remaining capacity.\n7. Scale the penalty scores by multiplying them with a scaling factor based on the maximum capacity and the average capacity.\n8. Calculate a difference score for each bin based on the absolute difference between its remaining capacity and the average capacity.\n9. Compute the final score for each bin by summing up the penalty scores, reward scores, priority scores, scaling factor, and difference scores.\n10. Return the scores for the bins for assignment.\n\nCode:\n\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    scores = np.empty(len(bins))\n    remaining_capacity = bins - item\n    max_capacity = np.max(bins)\n    avg_capacity = np.mean(bins)\n    \n    penalty_score = np.square(remaining_capacity - avg_capacity)\n    \n    reward_score = item - remaining_capacity * 0.5\n    \n    priority_score = 1 / remaining_capacity\n    \n    scaling_factor = max_capacity / (np.max(bins) - avg_capacity)\n    \n    difference_score = np.abs(remaining_capacity - avg_capacity)\n    \n    scores = penalty_score + reward_score + priority_score + scaling_factor + difference_score\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]