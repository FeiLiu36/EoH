[
     {
          "algorithm": "New algorithm description:\nThe new algorithm assigns a score to each bin based on the ratio between its remaining capacity and the item size, while also penalizing bins that cannot accommodate the item. The main steps are as follows:\n\n1. Find the minimum remaining capacity among the bins.\n2. Calculate a priority factor for each bin by dividing the item size by its remaining capacity.\n3. Initialize an array of scores with zeros.\n4. For each bin:\n   a. If the remaining capacity is less than the item size:\n      - Set the score for that bin to -inf to indicate that it cannot accommodate the item.\n   b. If the bin can accommodate the item:\n      - Calculate the score by multiplying the priority factor by the ratio of remaining capacity to item size, and subtracting the square of the item size.\n   c. If the remaining capacity is equal to the minimum remaining capacity:\n      - Set the score for that bin to -inf to exclude it from being used.\n5. Multiply the scores by 1 for bins that can accommodate the item and by infinity for bins that cannot.\n6. Return the resulting scores array.\n\nCode:\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    min_remaining_capacity = np.min(bins)\n    priority_factor = item / min_remaining_capacity\n\n    low_capacity_bins = bins < item\n\n    scores = np.zeros(len(bins), dtype=np.float64)\n    scores[low_capacity_bins] = -np.inf\n    scores[bins == min_remaining_capacity] = -np.inf\n    scores[~(low_capacity_bins | (bins == min_remaining_capacity))] = bins[~(low_capacity_bins | (bins == min_remaining_capacity))] * (priority_factor * bins[~(low_capacity_bins | (bins == min_remaining_capacity))] / item) - np.power(item, 2)\n\n    scores = scores * (1 - (low_capacity_bins | (bins == min_remaining_capacity))) + (low_capacity_bins | (bins == min_remaining_capacity)) * np.inf\n\n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]