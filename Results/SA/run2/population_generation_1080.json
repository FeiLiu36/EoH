[
     {
          "algorithm": "Algorithm Description: \n\nThe new algorithm assigns scores to bins based on two factors - the remaining capacity of the bins after assigning the item and the ratio of the remaining capacity to the item size. \n\n1. Calculate the remaining capacity of the bins by subtracting the item size from each bin's rest capacity.\n2. Calculate the weight for the remaining capacity by dividing it by the maximum capacity of the bins. Use np.exp function to compute the exponential value of the negative ratio.\n3. Calculate the weight for the ratio of remaining capacity to item size by subtracting the absolute value of the remaining capacity divided by the item size from 1.\n4. Create an array named 'scores' with zeros similar to the 'bins' array.\n5. Calculate the scores for each bin based on the following conditions:\n   - If the bin's rest capacity is greater than or equal to the item size, assign the score as the product of the remaining weight and the ratio weight for that bin.\n   - For bins with rest capacity less than the item size, assign a score of 0.\n6. Return the 'scores' array.\n\nPython Code: \n\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate the remaining capacity\n    remaining_capacity = bins - item\n    \n    # Calculate the weight for the remaining capacity\n    remaining_weight = np.exp(-(remaining_capacity) / (np.max(bins) - item))\n    \n    # Calculate the weight for the ratio of remaining capacity to item size\n    ratio_weight = 1 - np.abs(remaining_capacity) / item\n    \n    # Initialize an array to store the scores\n    scores = np.zeros_like(bins)\n        \n    # Calculate the scores for each bin\n    scores[bins >= item] = np.multiply(remaining_weight[bins >= item], ratio_weight[bins >= item])\n    \n    return scores",
          "objective": 0.04095,
          "other_inf": null
     }
]