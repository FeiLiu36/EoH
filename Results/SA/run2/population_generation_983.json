[
     {
          "algorithm": "/** The Modified Adaptive Capacity Distance Algorithm with Weighted Bin Selection aims to assign items to bins by considering the remaining capacities of the bins, dynamically selecting the bin based on its capacity and efficiency, promoting balanced utilization of the bins, incorporating a distance-based scoring mechanism and weighted bin selection, and also taking into account the number of items already assigned to each bin. **/\n\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    max_capacity = np.max(bins)\n    avg_capacity = np.mean(bins)\n    std_capacity = np.std(bins)\n    diff_capacity = remaining_capacity - avg_capacity\n    weights = np.exp(-diff_capacity)\n    capacity_ratio = remaining_capacity / max_capacity\n    bin_efficiency = remaining_capacity / bins\n    assigned_items = np.sum(bins) - np.sum(remaining_capacity)\n    distance_score = np.abs(remaining_capacity - avg_capacity)\n    weighted_distance_score = distance_score * weights\n    weights_ratio = np.mean(weights) / weights\n    scores = ((np.exp(-((diff_capacity / max_capacity) + 0.5) / (1 - capacity_ratio)) * weights_ratio * weighted_distance_score) \n              - (0.5 * (diff_capacity / max_capacity)) - (0.2 * bin_efficiency) - (0.1 * assigned_items))\n    median_score = np.median(scores)\n    scaled_scores = scores / median_score\n    penalty_term = np.abs(bins - np.median(bins))\n    scaled_scores -= penalty_term / max(penalty_term)\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]