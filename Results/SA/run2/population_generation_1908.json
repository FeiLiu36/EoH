[
     {
          "algorithm": "The new algorithm assigns scores to the bins based on a penalty factor that incorporates information about both the remaining capacity and the maximum capacity, taking into account the ratio of the item size to the remaining capacity, with additional weight given to bins with larger remaining capacities and a penalty for unused bins. The scores are then adjusted based on the number of items already assigned to each bin, giving more weight to bins with fewer items. Finally, the scores are normalized to fall within the range [0, 1].",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate the remaining capacity of the bins\n    remaining_capacity = bins - item\n    \n    # Calculate the penalty factor that takes into account remaining capacity and maximum capacity, with extra penalty for unused bins\n    penalty_factor = (remaining_capacity**2) / (bins**2) * (np.where(bins-item > 0, 1, 2))\n    \n    # Calculate the ratio of item size to remaining capacity\n    ratio = item / remaining_capacity\n    \n    # Assign scores to the bins based on the ratio\n    scores = ratio\n    \n    # Adjust the scores to give more weight to bins with larger remaining capacities\n    scores *= penalty_factor\n    \n    # Adjust the scores based on the number of items already assigned to each bin\n    num_items = bins.size - np.count_nonzero(remaining_capacity)\n    scores -= num_items\n    \n    # Normalize the scores to fall within the range [0, 1]\n    min_score = np.min(scores)\n    max_score = np.max(scores)\n    normalized_scores = (scores - min_score) / (max_score - min_score)\n    \n    return scores",
          "objective": 0.0156,
          "other_inf": null
     }
]