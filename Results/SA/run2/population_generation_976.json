[
     {
          "algorithm": "New algorithm description: The Enhanced Weighted Capacity Score Algorithm with Bin Efficiency aims to assign items to bins by considering the difference in capacities and penalizing bins with large differences and low ratios of remaining capacity, while also taking into account the efficiency of each bin based on its remaining capacity and the total capacity.\n\nCode:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate the remaining capacities of the bins\n    remaining_capacity = bins - item\n\n    # Calculate the maximum capacity among the bins\n    max_capacity = np.max(bins)\n\n    # Calculate the average and standard deviation of the capacities of the bins\n    avg_capacity = np.mean(bins)\n    std_capacity = np.std(bins)\n\n    # Calculate the difference between the remaining capacity of each bin and the average capacity\n    diff_capacity = remaining_capacity - avg_capacity\n\n    # Calculate the weight for each bin based on the difference in capacities using an exponential function\n    weights = np.exp(-diff_capacity)\n\n    # Calculate the ratio of the remaining capacity of each bin to the maximum capacity\n    capacity_ratio = remaining_capacity / max_capacity\n\n    # Calculate the efficiency of each bin based on the remaining capacity and the total capacity\n    bin_efficiency = remaining_capacity / bins\n\n    # Calculate the score based on the weighted capacity differences, the capacity ratio, and the bin efficiency,\n    # penalizing large differences, low ratios, and low efficiency\n    scores = (np.exp(-((diff_capacity / max_capacity) + 0.5) / (1 - capacity_ratio)) * weights) - (0.5 * (diff_capacity / max_capacity)) - (0.2 * bin_efficiency)\n\n    # Minimize the score of bins with remaining capacity equal to the maximum capacity\n    scores[remaining_capacity == max_capacity] = -np.inf\n\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]