[
     {
          "algorithm": "The Modified Weighted Capacity Distance Algorithm with Priority-Based Bin Selection aims to assign items to bins by considering the remaining capacities of the bins, dynamically selecting the bin based on its capacity and efficiency, promoting balanced utilization of the bins, incorporating a distance-based scoring mechanism and weighted bin selection, taking into account the number of items already assigned to each bin, and assigning higher scores to bins with higher priority values, calculated based on their previous performance.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    max_capacity = np.max(bins)\n    avg_capacity = np.mean(bins)\n    std_capacity = np.std(bins)\n    diff_capacity = remaining_capacity - avg_capacity\n    weights = np.exp(-diff_capacity)\n    capacity_ratio = remaining_capacity / max_capacity\n    bin_efficiency = remaining_capacity / bins\n    assigned_items = np.sum(bins) - np.sum(remaining_capacity)\n    distance_score = np.abs(remaining_capacity - avg_capacity)\n    weighted_distance_score = distance_score * weights\n    weights_ratio = np.mean(weights) / weights\n    priority_scores = np.array([0.5, 0.3, 0.2])  # Example priority scores for bins, can be customized\n    priority_based_scores = weights_ratio * priority_scores[:, np.newaxis]\n    scores = ((np.exp(-((diff_capacity / max_capacity) + 0.5) / (1 - capacity_ratio)) * priority_based_scores * weighted_distance_score) \n              - (0.5 * (diff_capacity / max_capacity)) - (0.2 * bin_efficiency) - (0.1 * assigned_items))\n    median_score = np.median(scores)\n    scaled_scores = scores / median_score\n    penalty_term = np.abs(bins - np.median(bins))\n    scaled_scores -= penalty_term / max(penalty_term)\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]