[
     {
          "algorithm": "My new algorithm calculates the score for each bin based on the remaining capacity, penalizes bins with higher items assigned, introduces a penalty for bins with remaining capacity close to their maximum, provides a bonus for bins with a large remaining capacity, and also considers the average size of items assigned to each bin. This algorithm aims to minimize the number of used bins.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate weighted base scores by subtracting the ratio of the remaining capacity to the item size from 1\n    base_scores = 1 - bins / item\n    \n    # Calculate penalty for bins with higher items assigned based on a linear decreasing penalty rate\n    high_item_penalty = np.maximum(0, (bins - item) / item)\n    \n    # Calculate penalty for bins with remaining capacity close to their maximum capacity with an increasing penalty rate\n    near_max_capacity_penalty = np.maximum(0, (1 - bins / np.max(bins)) * np.where((bins >= 0.8 * np.max(bins)), 0.2, 0))\n    \n    # Calculate bonus for bins with a large remaining capacity with an increasing bonus rate\n    large_capacity_bonus = np.maximum(0, (bins - item * 1.2) / item * np.where((bins > item * 1.2), 0.2, 0))\n    \n    # Calculate average size of items assigned to each bin\n    average_size = (np.sum(bins) - bins) / (len(bins) - 1)\n    \n    # Calculate penalty for bins with a higher average size of items assigned\n    higher_average_penalty = np.maximum(0, (bins - average_size) / average_size)\n\n    # Calculate final scores by combining weighted base scores, high item penalty, near-maximum capacity penalty, large capacity bonus, and higher average penalty\n    scores = base_scores - high_item_penalty - near_max_capacity_penalty + large_capacity_bonus - higher_average_penalty\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]