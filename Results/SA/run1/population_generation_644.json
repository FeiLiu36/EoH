[
     {
          "algorithm": "The new algorithm calculates the scores for the bins by taking the natural logarithm of the product of the square root of the remaining capacity of each bin and the square root of the item size, multiplies it by the reciprocal of the square root of the bin capacity, subtracts the minimum value across all bins from the obtained scores, adds the maximum value across all bins to the scores, then cubes each score, and finally normalizes the scores by dividing them by the sum of all cubed scores.\n\nHere's the implementation of the new algorithm in Python:\n\n```\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    \"\"\"The new algorithm calculates the scores for the bins by taking the natural logarithm of the product of the square root of the remaining capacity of each bin and the square root of the item size, multiplies it by the reciprocal of the square root of the bin capacity, subtracts the minimum value across all bins from the obtained scores, adds the maximum value across all bins to the scores, then cubes each score, and finally normalizes the scores by dividing them by the sum of all cubed scores.\"\"\"\n\n    # Calculate the square root of the remaining capacity of each bin\n    sqrt_capacity = np.sqrt(bins)\n\n    # Calculate the square root of the item size\n    sqrt_item = np.sqrt(item)\n\n    # Calculate the product of the square root of the remaining capacity and the square root of the item size\n    product_sqrt = sqrt_capacity * sqrt_item\n\n    # Calculate the natural logarithm of the product\n    log_product = np.log(product_sqrt)\n\n    # Calculate the reciprocal of the square root of the bin capacity\n    rec_sqrt_capacity = 1 / np.sqrt(bins)\n\n    # Calculate the scores by multiplying the natural logarithm of the product by the reciprocal of the square root of the bin capacity\n    scores = log_product * rec_sqrt_capacity\n\n    # Subtract the minimum value across all bins from the scores\n    scores -= np.min(scores)\n\n    # Add the maximum value across all bins to the scores\n    scores += np.max(scores)\n    \n    # Cube each score\n    scores = np.power(scores, 3)\n    \n    # Normalize the scores by dividing them by the sum of all cubed scores\n    scores /= np.sum(scores)\n\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]