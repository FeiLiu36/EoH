[
     {
          "algorithm": "New algorithm description: The modified algorithm aims to assign scores to the bins based on the rest capacity of each bin. It introduces a new 'sinusoidal_squared' term that calculates the square of the sine function of the difference between the rest capacity and the square root of the item size divided by the maximum capacity.\n\nCode:\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate statistics\n    max_capacity = np.max(bins)\n    \n    # Additional variables\n    weight_power = 0.1\n    weight_log = 0.1\n    weight_linear = 0.1\n    weight_sigmoid = 0.1\n    weight_exponential = 0.05\n    weight_sqrt = 0.05\n    weight_ratio = 0.05\n    weight_quadratic = 0.05\n    weight_inverse = 0.05\n    weight_exponential2 = 0.05\n    weight_logistic = 0.1\n    weight_geometric = 0.05\n    weight_cubic = 0.05\n    weight_sinusoidal = 0.05\n    weight_exponential3 = 0.05\n    weight_exponential4 = 0.05\n    weight_sigmoid2 = 0.1\n    weight_exponential_squared = 0.05\n    weight_sinusoidal_squared = 0.05\n    \n    # Scoring terms (Modified to include power, logarithmic, linear, sigmoid,\n    # exponential, square root, ratio, quadratic, inverse, exponential2,\n    # logistic, geometric, cubic, sinusoidal, exponential3, exponential4, sigmoid2,\n    # exponential_squared, and sinusoidal_squared terms)\n    power_term = np.power(1 / (bins / item), weight_power) # Inverse of the rest capacity divided by item capacity raised to a specified power\n    logarithmic_term = np.log1p(bins + item) # Logarithm of the sum of rest capacity and item capacity\n    linear_term = (bins / max_capacity) * weight_linear # Linear term multiplied by rest capacity divided by maximum capacity\n    sigmoid_term = 1 / (1 + np.exp(-weight_sigmoid * (bins - item))) # Sigmoid function of the difference between rest capacity and item capacity\n    exponential_term = np.exp(-(bins - item) / max_capacity) # Exponential of the difference between rest capacity and item capacity\n    sqrt_term = np.sqrt(bins + max_capacity) # Square root of the sum of rest and maximum capacity of bins\n    ratio_term = np.power(bins / (bins - item), 2) # Rest capacity divided by item capacity\n    quadratic_term = np.zeros_like(bins)\n    quadratic_term[:7] = (bins[:7] ** 2) / 3\n    inverse_term = 1 / np.power(bins / item, weight_inverse) # Inverse of the rest capacity divided by item capacity\n    exponential2_term = np.exp(-np.abs(bins - item) / max_capacity) # Exponential of the absolute difference between rest capacity and item capacity\n    logistic_term = 1 / (1 + np.exp(-weight_logistic * (bins - item))) # Logistic function of the difference between rest capacity and item capacity\n    geometric_term = np.power((bins * item), weight_geometric) # Geometric mean of the rest capacity and the item size\n    cubic_term = np.power(bins / item, 3) # Cubic power of the rest capacity divided by item size\n    sinusoidal_term = np.sin(np.pi * (bins - item) / max_capacity) # Sine of the difference between rest capacity and item capacity\n    exponential3_term = np.exp(np.power(bins / item, weight_exponential3)) # Exponential of the rest capacity divided by item capacity raised to a specified power\n    exponential4_term = np.exp(np.power(bins / (item + max_capacity), weight_exponential4)) # Exponential of the rest capacity divided by the sum of item size and maximum capacity raised to a specified power\n    sigmoid2_term = 1 / (1 + np.exp(-weight_sigmoid2 * (bins / (item + max_capacity)))) # Sigmoid function of the rest capacity divided by the sum of item size and maximum capacity\n    exponential_squared_term = np.exp(-(np.power(bins - (2*item), 2)) / max_capacity) # Exponential of the square of the difference between the rest capacity and twice the item size divided by the maximum capacity\n    sinusoidal_squared_term = np.power(np.sin(np.pi * (bins - np.sqrt(item)) / max_capacity), 2) # Square of the sine of the difference between rest capacity and the square root of the item size divided by the maximum capacity\n    \n    scores = (\n        weight_power * power_term\n        + weight_log * logarithmic_term\n        + weight_linear * linear_term\n        + weight_sigmoid * sigmoid_term\n        + weight_exponential * exponential_term\n        + weight_sqrt * sqrt_term\n        + weight_ratio * ratio_term\n        + weight_quadratic * quadratic_term\n        + weight_inverse * inverse_term\n        + weight_exponential2 * exponential2_term\n        + weight_logistic * logistic_term\n        + weight_geometric * geometric_term\n        + weight_cubic * cubic_term\n        + weight_sinusoidal * sinusoidal_term\n        + weight_exponential3 * exponential3_term\n        + weight_exponential4 * exponential4_term\n        + weight_sigmoid2 * sigmoid2_term\n        + weight_exponential_squared * exponential_squared_term\n        + weight_sinusoidal_squared * sinusoidal_squared_term\n    ) / (\n        weight_power\n        + weight_log\n        + weight_linear\n        + weight_sigmoid\n        + weight_exponential\n        + weight_sqrt\n        + weight_ratio\n        + weight_quadratic\n        + weight_inverse\n        + weight_exponential2\n        + weight_logistic\n        + weight_geometric\n        + weight_cubic\n        + weight_sinusoidal\n        + weight_exponential3\n        + weight_exponential4\n        + weight_sigmoid2\n        + weight_exponential_squared\n        + weight_sinusoidal_squared\n    )\n    \n    return scores",
          "objective": 0.00694,
          "other_inf": null
     }
]