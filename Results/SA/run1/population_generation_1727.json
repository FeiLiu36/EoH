[
     {
          "algorithm": "The new algorithm is called the \"Weighted Gaussian Score Function\" and it assigns items to bins while minimizing the number of used bins by using a weighted Gaussian scoring technique.\n\n```\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_capacity = np.max(bins)\n    average_capacity = np.mean(bins)\n    \n    # Additional variables\n    weight = 0.7\n    standard_deviation = 0.2 * max_capacity\n    \n    # Scoring terms\n    quadratic_term = np.zeros_like(bins)\n    quadratic_term[:7] = (bins[:7] ** 2) / 4\n    \n    ratio_term = np.power(bins / (item - bins), 2)\n    \n    capacity_term = np.exp(-(bins - item)**2 / (2 * standard_deviation**2))\n    \n    difference_term = np.exp(-np.abs(bins - item) / (2*standard_deviation**2))\n    \n    penalty_term = np.exp(-bins / (2 * max_capacity**2))\n    \n    deviation_term = np.exp(-np.abs(bins - average_capacity) / (2 * max_capacity**2))\n    \n    optimization_term = np.exp(-bins / (2 * max_capacity**2))\n    \n    balance_term = np.exp(-np.abs(bins - average_capacity) / (2 * max_capacity**2))\n    \n    # Calculate scores with the modified weighted Gaussian algorithm\n    scores = (\n        weight * capacity_term + quadratic_term + ratio_term - difference_term - penalty_term +\n        (1 - weight) * (deviation_term + optimization_term - balance_term)\n    ) / (\n        np.max(\n            weight * capacity_term + quadratic_term + ratio_term - difference_term - penalty_term +\n            (1 - weight) * (deviation_term + optimization_term - balance_term)\n        )\n    )\n    \n    return scores",
          "objective": 0.00714,
          "other_inf": null
     }
]