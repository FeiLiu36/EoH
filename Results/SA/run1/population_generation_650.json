[
     {
          "algorithm": "New algorithm description: The new modified algorithm calculates the scores for the bins by taking the reciprocal of the sum of the squares of the remaining capacity of each bin and the square root of the item size, multiplies it with the exponentiation of the ratio between the maximum capacity and the remaining capacity of each bin, subtracts the minimum value across all bins from the obtained scores, adds the maximum value across all bins to the scores, then normalizes the scores by dividing them by the sum of all scores.\n\nCode:\n\n```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    \"\"\"The new modified algorithm calculates the scores for the bins by taking the reciprocal of the sum of the squares of\n    the remaining capacity of each bin and the square root of the item size, multiplies it with the exponentiation of the \n    ratio between the maximum capacity and the remaining capacity of each bin, subtracts the minimum value across all bins from\n    the obtained scores, adds the maximum value across all bins to the scores, then normalizes the scores by dividing them by\n    the sum of all scores.\"\"\"\n    \n    # Calculate the reciprocal of the sum of the squares of the remaining capacity of each bin and the square root of the item size\n    rec_sum = 1 / (np.sum(np.square(bins)) + np.sqrt(item))\n    \n    # Multiply the reciprocal sum by the exponentiation of the ratio between max capacity and remaining capacity of each bin\n    rec_sum *= np.exp(np.max(bins) / bins)\n    \n    # Subtract the minimum value across all bins from the scores\n    scores = rec_sum - np.min(rec_sum)\n    \n    # Add the maximum value across all bins to the scores\n    scores += np.max(rec_sum)\n    \n    # Normalize the scores by dividing them by the sum of all scores\n    scores /= np.sum(scores)\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]