[
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    scaling_factor = 0.7\n    \n    max_capacity = np.max(bins)\n    \n    # Compute the difference between the rest capacity of a bin and the size of the current item\n    difference = item - bins\n    abs_difference = np.abs(difference)\n    \n    # Compute penalty term that penalizes large differences between rest capacity and item size\n    penalty = scaling_factor * np.exp(-abs_difference) / (max_capacity * max_capacity + 1)\n    \n    # Compute a reward term that rewards smaller differences\n    reward = scaling_factor * np.exp(-abs_difference) / (max_capacity * max_capacity + 1)\n    \n    # Compute the standard deviation of the rest capacities across all bins\n    std_deviation = np.std(bins)\n    \n    # Compute a term that balances the difference between the rest capacity and item size\n    # and the standard deviation of the rest capacities\n    balanced_term = scaling_factor * (1 / (difference / (bins * bins + 1))) - scaling_factor * (1 / (std_deviation * std_deviation + 1))\n    \n    # Compute a logarithmic term based on the rest capacity of the bin\n    log_term = scaling_factor * np.log(np.abs(bins)) / (np.log(max_capacity) + 1)\n    \n    # Compute a term that promotes using bins with larger rest capacities\n    promotion_term = scaling_factor * (std_deviation / max_capacity)\n    \n    # Compute the final scores by summing all the terms\n    scores = penalty + reward + balanced_term + log_term + promotion_term\n    \n    # Sort the scores in descending order\n    sorted_scores = np.sort(scores)[::-1]\n    \n    return scores",
          "objective": 0.0163,
          "other_inf": null
     }
]