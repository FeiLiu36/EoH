[
     {
          "algorithm": "New algorithm: Modified Weighted Score Function Algorithm\n\nThe main steps of the algorithm are as follows:\n\n1. Calculate the maximum capacity of the bins.\n2. Calculate the ratio term by taking the inverse of the difference between the item and the bin size divided by the square of the capacity plus 1, multiplied by a weight factor.\n3. Calculate the capacity term by subtracting the rest capacities of the bins from the maximum capacity and dividing it by the maximum capacity, multiplied by a weight factor.\n4. Calculate the penalty term, which penalizes bins close to maximum capacity, using the formula: ((bins - max_capacity) / max_capacity) ** 2, multiplied by a weight factor.\n5. Calculate the proximity term, which penalizes bins farther away from maximum capacity, using the formula: (bins / max_capacity) ** 2, multiplied by a weight factor.\n6. Calculate the scores for the bins by summing the ratio term, capacity term, penalty term, and proximity term.\n7. Sort the scores in descending order.\n8. Return the scores.\n\nHere is the Python implementation of the new algorithm:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_capacity = np.max(bins)\n    weight = 0.5\n\n    # Ratio term\n    ratio_term = weight * (1 / ((item - bins) / (bins**2 + 1)))\n\n    # Capacity term\n    capacity_term = weight * ((max_capacity - bins) / max_capacity)\n\n    # Penalty term\n    penalty_term = weight * ((bins - max_capacity) / max_capacity) ** 2\n\n    # Proximity term\n    proximity_term = weight * (bins / max_capacity) ** 2\n\n    # Calculate scores\n    scores = ratio_term + capacity_term - penalty_term - proximity_term\n\n    # Sort scores in descending order\n    sorted_scores = np.sort(scores)[::-1]\n\n    return scores",
          "objective": 0.01439,
          "other_inf": null
     }
]