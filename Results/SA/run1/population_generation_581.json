[
     {
          "algorithm": "",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    \"\"\"The New Modified Score Algorithm calculates the scores for the bins by taking the sum of the remaining capacity of each bin, \n    multiplying it by the logarithm of the item size raised to the power of 2, \n    subtracting the square root of the maximum remaining capacity from the product, \n    then multiplying by an increasing geometric sequence of weights raised to the power of 2, \n    and finally taking the maximum score across all bins.\"\"\"\n    \n    # Calculate the remaining capacity of each bin\n    remaining_capacity = bins - item\n    \n    # Calculate the sum of the remaining capacity of each bin\n    sum_remaining_capacity = np.sum(remaining_capacity)\n    \n    # Calculate the logarithm of the item size raised to the power of 2\n    log_item_square = np.log(item) ** 2\n    \n    # Calculate the product of the sum of the remaining capacity and the logarithm of the item size raised to the power of 2\n    product = sum_remaining_capacity * log_item_square\n    \n    # Calculate the maximum remaining capacity\n    max_remaining_capacity = np.max(remaining_capacity)\n    \n    # Subtract the square root of the maximum remaining capacity from the product\n    scores = product - np.sqrt(max_remaining_capacity)\n    \n    # Calculate the increasing geometric sequence of weights raised to the power of 2\n    weights_powered = np.power(np.arange(1, len(bins)+1), 2)\n    \n    # Multiply the scores by the increasing geometric sequence of weights raised to the power of 2\n    scores *= weights_powered\n    \n    # Take the maximum score across all bins\n    max_score = np.max(scores)\n    \n    return scores",
          "objective": 0.04236,
          "other_inf": null
     }
]