[
     {
          "algorithm": "New algorithm description: My new algorithm applies a modified scoring function that considers the difference between the rest capacity of a bin and the size of the current item, the average capacity across all bins, the logarithm of the rest capacity of the bin, and a term that promotes using bins with larger rest capacities. It also introduces a penalty term that penalizes large differences between rest capacity and item size, and a reward term that rewards smaller differences. The scoring function is adjusted by a scaling factor to control the impact of the penalty and reward terms.\n\nNew algorithm implementation:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    scaling_factor = 0.5  # Adjust the impact of penalty and reward terms\n    \n    max_capacity = np.max(bins)\n\n    difference = item - bins\n\n    penalty = scaling_factor * np.exp(-np.abs(difference)) / (max_capacity * max_capacity + 1)\n\n    reward = scaling_factor * np.exp(-np.abs(item - bins)) / (max_capacity * max_capacity + 1)\n\n    average_capacity = np.mean(bins)\n\n    balanced_term1 = scaling_factor * (1 / (difference / (bins * bins + 1))) - scaling_factor * (1 / (average_capacity * average_capacity + 1))\n\n    log_term = scaling_factor * (np.log(np.abs(bins)) + 1) / (np.log(max_capacity) + 1)\n\n    promotion_term = scaling_factor * (average_capacity / max_capacity)\n\n    scores = penalty + reward + balanced_term1 + log_term + promotion_term\n\n    sorted_scores = np.sort(scores)[::-1]\n\n    return scores",
          "objective": 0.0163,
          "other_inf": null
     }
]