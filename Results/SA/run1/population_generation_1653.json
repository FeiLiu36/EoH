[
     {
          "algorithm": "New Algorithm: Exponential Score Function\n\nIn this new algorithm, the score function assigns scores to bins based on the remaining capacities of the bins, the difference between the bin capacity and the item size, penalty terms, and an exponential factor that considers the ratio between the remaining capacity of each bin and the average remaining capacity. The algorithm aims to minimize the number of used bins by giving higher scores to bins with more remaining capacity and penalizing bins with a lower number of items already assigned. Additionally, the exponential algorithm introduces an exponential decay factor that decreases the score of bins with larger differences in remaining capacity. The exponential algorithm also incorporates a modified version of the existing penalty term and adjusts the weight factor for the optimization term.\n\nCode:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_capacity = np.max(bins)\n    average_capacity = np.mean(bins)\n    threshold = 0.4 * max_capacity\n    \n    # Additional variables\n    penalty_factor = 0.8\n    decay_factor = 0.5\n    count_factor = 0.6\n    weight_factor = 0.3\n    \n    # Scoring terms\n    quadratic_term = np.zeros_like(bins)\n    quadratic_term[:7] = (bins[:7] ** 2) / 4  # Quadratic term\n\n    ratio_term = np.power(bins / (item - bins), 2)  # Ratio term\n    \n    capacity_term = np.exp(-0.1 * (max_capacity - bins))  # Capacity term with exponential factor\n    \n    difference_term = np.abs(bins - item)  # Difference term\n    \n    count_term = np.exp(-0.2 * bins)  # Count term\n    \n    penalty_term = np.exp((bins - average_capacity) / (0.3 * max_capacity)) * (bins > average_capacity)  # Penalty term\n    \n    ratio_penalty_term = 1 / (bins + 1) * np.exp(-(bins / max_capacity))  # Ratio penalty term (modified)\n    \n    decay_term = np.exp(-decay_factor * np.abs(bins - average_capacity))  # Exponential decay term\n    \n    optimization_term = weight_factor * (1 / (bins + 1))  # Optimization term with weight factor\n    \n    # Calculate scores with the exponential algorithm\n    scores = (\n        3 * capacity_term + quadratic_term + 2 * ratio_term - penalty_factor * difference_term - penalty_factor * penalty_term +\n        ratio_penalty_term + decay_term + count_factor * count_term + optimization_term\n    ) / (\n        np.max(\n            3 * capacity_term + quadratic_term + 2 * ratio_term - penalty_factor * difference_term - penalty_factor * penalty_term +\n            ratio_penalty_term + decay_term + count_factor * count_term + optimization_term\n        )\n    )\n\n    return scores",
          "objective": 0.00835,
          "other_inf": null
     }
]