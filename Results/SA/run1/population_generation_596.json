[
     {
          "algorithm": "The new algorithm calculates the scores for the bins by taking the exponential function raised to the power of the square root of the ratio between the maximum remaining capacity and the item size plus a constant, multiplied by the logarithmic function raised to the power of the sum of the remaining capacities of all bins plus a constant, then multiplied by the reciprocal of the weights squared, and finally adding the sum of the remaining capacities to the maximum score across all bins.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    \"\"\"The new algorithm calculates the scores for the bins by taking the exponential function raised to the power of the square root of the ratio between the maximum remaining capacity and the item size plus a constant,\n    multiplied by the logarithmic function raised to the power of the sum of the remaining capacities of all bins plus a constant,\n    then multiplied by the reciprocal of the weights squared,\n    and finally adding the sum of the remaining capacities to the maximum score across all bins.\"\"\"\n\n    # Calculate the remaining capacity of each bin\n    remaining_capacity = bins - item\n\n    # Calculate the maximum remaining capacity\n    max_remaining_capacity = np.max(remaining_capacity)\n\n    # Calculate the ratio between the maximum remaining capacity and the item size plus a constant\n    ratio = np.sqrt(max_remaining_capacity / (item + 1e-10))\n\n    # Calculate the exponential function raised to the power of the square root of the ratio\n    exponential_function = np.exp(np.sqrt(ratio))\n\n    # Calculate the logarithmic function raised to the power of the sum plus a constant\n    logarithmic_sum = np.log(np.sum(remaining_capacity) + 1e-10)\n\n    # Calculate the reciprocal of the weights squared\n    reciprocal_weights_squared = 1 / np.power(np.arange(1, len(bins) + 1), 2)\n\n    # Calculate the product of the exponential function, the logarithmic sum plus a constant, and the reciprocal of the weights squared\n    product = exponential_function * np.power(logarithmic_sum, reciprocal_weights_squared)\n\n    # Add the sum of the remaining capacities to the maximum score across all bins\n    scores = product + np.sum(remaining_capacity)\n\n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]