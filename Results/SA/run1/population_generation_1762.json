[
     {
          "algorithm": "(Modified Exponential Decay Score Function) The new algorithm modifies the penalty term in the original algorithm to use an exponential decay function that considers the difference between each bin's capacity and the item size, scaled by the standard deviation, squared. The algorithm then calculates the overall scores for the bins using the modified score function by summing up the individual terms and normalizing the scores.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_capacity = np.max(bins)\n    average_capacity = np.mean(bins)\n\n    # Additional variables\n    weight = 0.6\n    exponent = 0.7\n    std_dev = (max_capacity - average_capacity) / 2\n\n    # Scoring terms\n    quadratic_term = np.zeros_like(bins)\n    quadratic_term[:7] = (bins[:7] ** 2) / 4\n\n    ratio_term = np.power(bins / (item - bins), 2)\n\n    difference_term = np.abs(bins - item)\n\n    decay_factor = np.exp(-difference_term / (2 * std_dev**2))  # Modified penalty term\n\n    deviation_term = np.abs(bins - average_capacity)\n\n    weighted_difference_term = weight * decay_factor\n\n    optimization_term = (1 - weight) * np.exp(-bins / (2 * std_dev**2))\n\n    balance_term = (1 - weight) * np.exp(-deviation_term / (2 * std_dev**2))\n\n    # Calculate scores with the modified exponential decay algorithm\n    scores = (\n        quadratic_term + ratio_term - decay_factor + weighted_difference_term +\n        optimization_term + balance_term\n    ) / (\n        np.max(\n            quadratic_term + ratio_term - decay_factor + weighted_difference_term +\n            optimization_term + balance_term\n        )\n    )\n\n    return scores",
          "objective": 0.00714,
          "other_inf": null
     }
]