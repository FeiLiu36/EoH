[
     {
          "algorithm": "New Algorithm: Modified Power Score Function\n\nThe new algorithm modifies the power score function by incorporating additional penalty terms based on the ratio between the remaining capacity of each bin and the maximum remaining capacity, as well as the difference between the remaining capacity of each bin and the size of the current item. The algorithm aims to minimize the number of used bins by giving higher scores to bins with more remaining capacity, penalizing bins with a lower number of items already assigned, and encouraging a more even distribution of items among the bins. The modified algorithm adjusts the weight factor and introduces an additional penalty factor for the optimization term.\n\nCode:\n\n```\n\nCode:\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_capacity = np.max(bins)\n    average_capacity = np.mean(bins)\n    \n    # Additional variables\n    penalty_factor = 0.8\n    power_factor = 0.5\n    count_factor = 0.6\n    weight_factor = 0.3\n    \n    # Scoring terms\n    quadratic_term = np.zeros_like(bins)\n    quadratic_term[:7] = (bins[:7] ** 2) / 4  # Quadratic term\n    \n    ratio_term = np.power(bins / (item - bins), 2)  # Ratio term\n    \n    capacity_term = np.power(bins / max_capacity, power_factor)  # Capacity term with power factor\n    \n    difference_term = np.power(np.abs(bins - item), power_factor)  # Difference term with power factor\n    \n    count_term = np.exp(-count_factor * bins)  # Count term\n    \n    penalty_term = (\n        np.exp(penalty_factor * (bins - average_capacity) / (0.3 * max_capacity)) *\n        (bins > average_capacity)\n    )  # Penalty term\n    \n    decay_term = np.exp(-0.5 * np.abs(bins - average_capacity))  # Exponential decay term\n    \n    optimization_term = weight_factor * (1 / (bins + 1))  # Optimization term with weight factor\n    \n    # Calculate scores with the modified power algorithm\n    scores = (\n        3 * capacity_term + quadratic_term + 2 * ratio_term - penalty_factor * difference_term - penalty_factor * penalty_term +\n        decay_term + count_term + optimization_term\n    ) / (\n        np.max(\n            3 * capacity_term + quadratic_term + 2 * ratio_term - penalty_factor * difference_term - penalty_factor * penalty_term +\n            decay_term + count_term + optimization_term\n        )\n    )\n    \n    return scores",
          "objective": 0.00795,
          "other_inf": null
     }
]