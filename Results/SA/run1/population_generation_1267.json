[
     {
          "algorithm": "The new algorithm will assign scores to the bins based on the difference between the rest capacity of a bin and the size of the current item. It will apply a series of mathematical operations to obtain the scores, including exponential decay, penalty and reward terms, balanced term based on the ratio of the difference to the square of the bin capacity, logarithmic term, and a promotion term based on the standard deviation of the bins compared to the maximum capacity. The scores will be sorted in descending order and returned as the final output.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    scaling_factor = 0.7\n    \n    max_capacity = np.max(bins)\n    \n    difference = item - bins\n    abs_difference = np.abs(difference)\n    \n    # Exponential decay term\n    decay_term = scaling_factor * np.exp(-abs_difference) / (max_capacity * max_capacity + 1)\n    \n    # Penalty term\n    penalty_term = scaling_factor * np.exp(-abs_difference) / (max_capacity * max_capacity + 1)\n    \n    # Balanced term based on ratio and standard deviation\n    ratio_term = scaling_factor * (1 / (difference / (bins * bins + 1))) - scaling_factor * (1 / (np.std(bins) * np.std(bins) + 1))\n    \n    # Logarithmic term\n    log_term = scaling_factor * np.log(np.abs(bins)) / (np.log(max_capacity) + 1)\n    \n    # Promotion term based on standard deviation\n    promotion_term = scaling_factor * (np.std(bins) / max_capacity)\n    \n    # Calculate scores\n    scores = decay_term + penalty_term + ratio_term + log_term + promotion_term\n    \n    # Sort scores in descending order\n    sorted_scores = np.sort(scores)[::-1]\n    \n    return scores",
          "objective": 0.0163,
          "other_inf": null
     }
]