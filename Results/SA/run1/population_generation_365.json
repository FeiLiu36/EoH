[
     {
          "algorithm": "The new algorithm calculates the score for each bin by taking the sum of the logarithm of the ratio of the rest capacity of the bin to the maximum capacity and the logarithm of the ratio of the item size to the rest capacity of the bin, both raised to the power of two, and then multiplies the result by a penalty factor that is proportional to the difference between the item size and the rest capacity of the bin.\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate the maximum capacity of the bins\n    max_capacity = np.max(bins)\n\n    # Calculate the ratio of the rest capacity of each bin to the maximum capacity\n    ratios = bins / max_capacity\n\n    # Calculate the ratio of the item size to the rest capacity of each bin\n    inverse_ratios = item / bins\n\n    # Calculate the logarithm of the ratio of the rest capacity of each bin to the maximum capacity, to the power of two\n    log_ratios_squared = np.log(ratios) ** 2\n\n    # Calculate the logarithm of the ratio of the item size to the rest capacity of each bin, to the power of two\n    log_inverse_ratios_squared = np.log(inverse_ratios) ** 2\n\n    # Calculate the difference between the item size and the rest capacity of each bin\n    differences = item - bins\n\n    # Calculate the penalty factor proportional to the difference between the item size and the rest capacity of the bin\n    penalty_factor = 0.1 * differences\n\n    # Calculate the scores for each bin by taking the sum of the logarithm of the ratio of the rest capacity of the bin to the maximum capacity,\n    # and the logarithm of the ratio of the item size to the rest capacity of the bin, both raised to the power of two,\n    # and multiplying the result by the penalty factor.\n    scores = (log_ratios_squared + log_inverse_ratios_squared) * penalty_factor\n\n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]