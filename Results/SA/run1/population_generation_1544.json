[
     {
          "algorithm": "The new algorithm assigns scores to bins based on the remaining capacities, penalizes bins that are close to their maximum capacity, rewards bins with larger remaining capacities, and includes a term that considers the difference between the bin capacity and the item size. It also incorporates a normalization term that divides each score by the maximum score to ensure all scores are between 0 and 1. Moreover, the algorithm adds an additional term that penalizes bins with capacities greater than twice the size of the item.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_capacity = np.max(bins)\n    threshold = 0.4 * max_capacity\n\n    quadratic_term = np.zeros_like(bins)\n    quadratic_term[:7] = 0.25 * (bins[:7] ** 2)  # Quadratic term\n\n    ratio_term = (bins ** 2) / ((item - bins) ** 2 + 1)  # Ratio term\n\n    capacity_term = np.exp(-0.6 * (bins - item) / item)  # Capacity term\n\n    difference_term = np.abs(bins - item)  # Difference term\n\n    penalty_term = np.exp((threshold - bins) / threshold) * (bins > threshold)  # Penalty term\n\n    additional_term = np.exp(-(bins - 2*item)/item)  # Additional term penalizing large bins\n    \n    scores = (2 * capacity_term + quadratic_term + ratio_term - difference_term - penalty_term - additional_term) / np.max(2 * capacity_term + quadratic_term + ratio_term - difference_term - penalty_term - additional_term)\n\n    return scores",
          "objective": 0.00835,
          "other_inf": null
     }
]