[
     {
          "algorithm": "My new algorithm calculates the scores for each bin based on the rest capacities of the bins and the size of the current item. It penalizes bins with larger capacities than the item size and rewards bins with similar capacities as the current item. The algorithm also takes into account a scaling factor to adjust the impact of the penalty and reward terms. Finally, the algorithm returns the scores for the bins for assignment.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    scaling_factor = 0.5  # Adjust the impact of penalty and reward terms\n\n    max_capacity = np.max(bins)\n    difference = item - bins\n    divided_sizes = difference / (bins * bins)\n    penalty = np.maximum(0, difference) * scaling_factor\n    reward = np.exp(-np.abs(bins - item)) * np.exp(-np.abs(bins - max_capacity)) * scaling_factor\n    scores = np.reciprocal(divided_sizes) + penalty + reward\n    \n    max_score = np.max(scores) # Maximum score\n    \n    if max_capacity == item: # Check if any bin has the same capacity as the item\n        scores = np.where(bins == item, max_score, scores)\n    \n    sorted_scores = np.sort(scores)[::-1]\n    return scores",
          "objective": 0.0156,
          "other_inf": null
     }
]