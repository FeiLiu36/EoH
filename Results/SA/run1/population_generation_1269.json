[
     {
          "algorithm": "The new algorithm assigns scores to the bins based on a combination of exponential decay, penalty and reward terms, balanced term using the ratio of the difference to the square of the bin capacity, logarithmic term, and a promotion term based on the standard deviation of the bins compared to the maximum capacity. The scores are then sorted in descending order and returned as the final output.\n\nHere is the modified algorithm implementation in Python:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    scaling_factor = 0.7\n    max_capacity = np.max(bins)\n    \n    difference = item - bins\n    abs_difference = np.abs(difference)\n    \n    # Exponential decay term\n    decay_term = scaling_factor * np.exp(-abs_difference) / (max_capacity**2 + 1)\n    \n    # Penalty term\n    penalty_term = scaling_factor * np.exp(-abs_difference) / (max_capacity**2 + 1)\n    \n    # Balanced term based on ratio and standard deviation\n    ratio_term = scaling_factor * (1 / (difference / (bins**2 + 1))) - scaling_factor * (1 / (np.std(bins)**2 + 1))\n    \n    # Logarithmic term\n    log_term = scaling_factor * np.log(np.abs(bins)) / (np.log(max_capacity) + 1)\n    \n    # Promotion term based on standard deviation\n    promotion_term = scaling_factor * (np.std(bins) / max_capacity)\n    \n    # Calculate scores\n    scores = decay_term + penalty_term + ratio_term + log_term + promotion_term\n    \n    # Sort scores in descending order\n    sorted_scores = np.sort(scores)[::-1]\n    \n    return scores",
          "objective": 0.0163,
          "other_inf": null
     }
]