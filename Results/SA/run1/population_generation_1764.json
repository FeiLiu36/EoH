[
     {
          "algorithm": "Modified Modified Exponential Decay Score Function: The new algorithm modifies the penalty term in the original algorithm by introducing a weighted exponential decay function that considers the difference between each bin's capacity and the item size, scaled by the average capacity and the standard deviation, squared. The algorithm then calculates the overall scores for the bins using the modified score function by summing up the individual terms and normalizing the scores.\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    # Calculate statistics\n    max_capacity = np.max(bins)\n    average_capacity = np.mean(bins)\n    std_dev = np.std(bins)\n\n    # Additional variables\n    weight = 0.6\n    exponential_factor = 0.7\n\n    # Scoring terms\n    quadratic_term = np.zeros_like(bins)\n    quadratic_term[:7] = (bins[:7] ** 2) / 4\n\n    ratio_term = np.power(bins / (item - bins), 2)\n\n    difference_term = np.abs(bins - item)\n\n    decay_factor = np.exp(-difference_term / (2 * (average_capacity * std_dev)**2))  # Modified penalty term\n\n    deviation_term = np.abs(bins - average_capacity)\n\n    weighted_difference_term = weight * decay_factor\n\n    optimization_term = (1 - weight) * np.exp(-bins / (2 * std_dev**2))\n\n    balance_term = (1 - weight) * np.exp(-deviation_term / (2 * std_dev**2))\n\n    # Calculate scores with the modified exponential decay algorithm\n    scores = (\n        quadratic_term + ratio_term - decay_factor + weighted_difference_term +\n        optimization_term + balance_term\n    ) / (\n        np.max(\n            quadratic_term + ratio_term - decay_factor + weighted_difference_term +\n            optimization_term + balance_term\n        )\n    )\n\n    return scores",
          "objective": 0.00714,
          "other_inf": null
     }
]