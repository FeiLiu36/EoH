[
     {
          "algorithm": "New Algorithm: Modified Exponential Score Function Algorithm\n\nThe main steps of the algorithm are as follows:\n1. Calculate the maximum capacity of the bins.\n2. Define the weight, beta, and m parameters.\n3. Sort the rest capacities of the bins in descending order.\n4. Initialize an array to store the exponential term values.\n5. Calculate the exponential term values for the first m bins using the modified formula: exp(bins[:m] / (max_capacity - item)) + 1.\n6. Calculate the ratio term values using the formula: weight * (bins**2 + 1) / ((item - bins) + 1).\n7. Calculate the capacity term values using the formula: weight * ((max_capacity - bins) / max_capacity).\n8. Calculate the penalty term values using the formula: weight * ((bins - max_capacity) / max_capacity) ** 2.\n9. Calculate the proximity term values using the formula: weight * (bins / max_capacity) ** 2.\n10. Calculate the scores for the bins using the formula: ratio term + exponential term + capacity term - penalty term - proximity term.\n11. Sort the scores in descending order.\n\nImplementation in Python:\n\n```\n",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_capacity = np.max(bins)\n    weight = 0.5\n    beta = 0.2\n    m = 5\n\n    sorted_bins = np.sort(bins)[::-1]\n    exponential_term = np.zeros_like(bins)\n    exponential_term[:m] = np.exp(bins[:m] / (max_capacity - item)) + 1\n\n    ratio_term = weight * (bins**2 + 1) / ((item - bins) + 1)\n    capacity_term = weight * ((max_capacity - bins) / max_capacity)\n    penalty_term = weight * ((bins - max_capacity) / max_capacity) ** 2\n    proximity_term = weight * (bins / max_capacity) ** 2\n\n    scores = ratio_term + exponential_term + capacity_term - penalty_term - proximity_term\n\n    sorted_scores = np.sort(scores)[::-1]\n\n    return scores",
          "objective": 0.01238,
          "other_inf": null
     }
]