[
     {
          "algorithm": "The new algorithm calculates the scores for the bins by taking the product of the inverse of the item size, \nthe reciprocal of the remaining capacity normalized by the maximum remaining capacity, and the exponential of the \nratio between the remaining capacity and the maximum remaining capacity, then subtracts the minimum score across all bins, \nsquares the result, and adds it to the sum of the maximum score across all bins.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    \"\"\"The new algorithm calculates the scores for the bins by taking the product of \n    the inverse of the item size, the reciprocal of the remaining capacity normalized by the maximum remaining capacity, \n    and the exponential of the ratio between the remaining capacity and the maximum remaining capacity, then subtracts \n    the minimum score across all bins, squares the result, and adds it to the sum of the maximum score across all bins.\"\"\"\n\n    # Calculate the remaining capacity of each bin\n    remaining_capacity = bins - item\n    \n    # Calculate the maximum remaining capacity\n    max_remaining_capacity = np.max(remaining_capacity)\n    \n    # Calculate the inverse of the item size\n    inverse_item_size = 1 / item\n    \n    # Calculate the reciprocal of the remaining capacity normalized by the maximum remaining capacity\n    reciprocal_capacity = 1 / (remaining_capacity / max_remaining_capacity)\n    \n    # Calculate the exponential of the ratio between the remaining capacity and the maximum remaining capacity\n    exp_ratio = np.exp(remaining_capacity / max_remaining_capacity)\n    \n    # Calculate the product of the inverse of the item size, the reciprocal of the remaining capacity normalized by the maximum remaining capacity,\n    # and the exponential of the capacity ratio\n    product = inverse_item_size * reciprocal_capacity * exp_ratio\n    \n    # Subtract the minimum score across all bins\n    min_score = np.min(product)\n    product -= min_score\n    \n    # Square the result\n    squared_product = np.square(product)\n    \n    # Take the sum of the maximum score across all bins\n    max_score = np.sum(np.max(squared_product, axis=0))\n    \n    # Calculate the scores for the bins\n    scores = np.sum(squared_product, axis=0) + max_score\n    \n    return scores",
          "objective": 0.04226,
          "other_inf": null
     }
]