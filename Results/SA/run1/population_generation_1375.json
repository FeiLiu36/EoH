[
     {
          "algorithm": "Algorithm description: Modified Exponential Score Function Algorithm\n\nThe main steps of the algorithm are as follows:\n\n1. Calculate the maximum capacity of the bins.\n2. Calculate the ratio term by taking the inverse of the difference between the item and the bin size divided by the square of the capacity plus 1, multiplied by a weight factor.\n3. Calculate the capacity term by subtracting the rest capacities of the bins from the maximum capacity and dividing it by the maximum capacity, multiplied by a weight factor.\n4. Calculate the penalty term, which penalizes bins close to maximum capacity, using the formula: ((bins - max_capacity) / max_capacity) ** 2, multiplied by a weight factor.\n5. Calculate the proximity term, which penalizes bins farther away from maximum capacity, using the formula: (bins / max_capacity) ** 2, multiplied by a weight factor.\n6. Calculate the exponential term, which weights the scores based on their position in the sorted scores list, using the formula: exp(-alpha * position) where alpha is a positive constant.\n7. Calculate the scores for the bins by summing the ratio term, capacity term, penalty term, proximity term, and the exponential term.\n8. Sort the scores in descending order.\n9. Return the scores.\n\nHere is the Python implementation of the new algorithm:\n\n```",
          "code": "import numpy as np\nimport math\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_capacity = np.max(bins)\n    weight = 0.5\n    alpha = 0.1\n\n    # Ratio term\n    ratio_term = weight * (1 / ((item - bins) / (bins**2 + 1)))\n\n    # Capacity term\n    capacity_term = weight * ((max_capacity - bins) / max_capacity)\n\n    # Penalty term\n    penalty_term = weight * ((bins - max_capacity) / max_capacity) ** 2\n\n    # Proximity term\n    proximity_term = weight * (bins / max_capacity) ** 2\n\n    # Exponential term\n    sorted_bins = np.sort(bins)[::-1]\n    positions = np.arange(1, len(bins) + 1)\n    exponential_term = np.exp(-alpha * positions)\n\n    # Calculate scores\n    scores = ratio_term + capacity_term - penalty_term - proximity_term + exponential_term\n\n    # Sort scores in descending order\n    sorted_scores = np.sort(scores)[::-1]\n\n    return scores",
          "objective": 0.01368,
          "other_inf": null
     }
]