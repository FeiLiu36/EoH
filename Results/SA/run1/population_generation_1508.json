[
     {
          "algorithm": "Algorithm Description: Modified algorithm with an additional term that rewards bins with larger remaining capacities, promoting the utilization of bins with higher capacity.\n\nCode:\n\n``` ",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    max_capacity = np.max(bins)\n    alpha = 0.1\n    n = 5\n    threshold = 0.3 * max_capacity\n\n    sorted_bins = np.sort(bins)\n\n    quadratic_term = np.zeros_like(bins)\n    quadratic_term[:n] = alpha * (bins[:n] ** 2)  # Quadratic term\n\n    ratio_term = (bins ** 2 + 1) / ((item - bins) + 1)  # Ratio term\n\n    capacity_term = bins / max_capacity  # Capacity term\n\n    penalty_term = np.exp((threshold - bins) / threshold)  # Penalty term\n\n    exponential_term = np.exp(-(bins - item) / (0.5 * item))  # Exponential term\n\n    neighbors_term = np.zeros_like(bins)\n    neighbors_term[1:-1] = np.where((bins[1:-1] < bins[:-2]) & (bins[1:-1] < bins[2:]), 1, 0)  # Neighbors term\n\n    average_capacity = np.mean(bins)\n    average_term = np.exp(-(bins - average_capacity) / average_capacity)  # Average term\n\n    max_capacity_term = np.where(bins == max_capacity, 1, 0)  # Maximum capacity term\n    \n    small_capacity_term = np.exp((bins - threshold) / threshold)  # Additional penalty term for small capacity bins\n    \n    low_capacity_term = np.exp(-bins / max_capacity)  # Term penalizing bins with remaining capacity close to zero\n\n    high_capacity_term = np.exp(bins / max_capacity)  # Term rewarding bins with larger remaining capacities\n\n    scores = (\n        quadratic_term + ratio_term + capacity_term - penalty_term + exponential_term + neighbors_term + average_term + max_capacity_term - small_capacity_term - low_capacity_term + high_capacity_term\n    )\n\n    sorted_scores = np.sort(scores)[::-1]\n\n    return scores",
          "objective": 0.01137,
          "other_inf": null
     }
]