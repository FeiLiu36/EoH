[
     {
          "algorithm": "New algorithm description: The new algorithm calculates the score for each bin based on the remaining capacity and item size, as well as the proximity to the maximum capacity and the sum of remaining capacities. It also incorporates a penalty for bins that have a lower remaining capacity than the item size, aiming to prevent overloading bins with small capacities.\n\nCode:\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n\n    # Calculate the penalty for bins with remaining capacity close to the maximum capacity\n    capacity_penalty = np.exp(-(remaining_capacity - bins) / item) * np.logical_not(remaining_capacity == bins)\n\n    # Calculate the score for capacity\n    capacity_score = np.exp(-remaining_capacity / item) + capacity_penalty\n\n    # Calculate the reward for bins with item size close to the remaining capacity\n    size_reward = np.exp((item - remaining_capacity) / bins) * np.logical_not(item == remaining_capacity)\n\n    # Calculate the score for size\n    size_score = np.exp(item / remaining_capacity) + size_reward\n\n    # Calculate the penalty for bins with lower remaining capacity than item size\n    capacity_diff_penalty = np.exp(-(item - remaining_capacity))\n\n    # Calculate the final scores\n    scores = np.where(remaining_capacity >= item, np.full_like(remaining_capacity, 1e9),\n                     capacity_score + size_score + capacity_diff_penalty)\n\n    return scores",
          "objective": 0.01197,
          "other_inf": null
     }
]