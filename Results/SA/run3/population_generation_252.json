[
     {
          "algorithm": "Algorithm description: The new algorithm assigns a score to each bin based on the remaining capacity and item size, giving higher scores to bins with more available capacity and penalizing bins with lower remaining capacity than the item size. It also incorporates a proximity score that assigns higher scores to bins that have less remaining capacity relative to their maximum capacity. The scores are calculated in a modified way to improve the performance of the function. The modified version includes additional penalty terms to discourage overfilling of bins and to encourage using bins with a closer proximity to their maximum capacity.\n\nCode:\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n\n    # Calculate the penalty for bins with lower remaining capacity than the item size\n    remaining_capacity_penalty = np.exp(-remaining_capacity / item) - 1\n\n    # Calculate the score for capacity\n    capacity_score = np.exp(-(item - remaining_capacity) / item) - remaining_capacity_penalty\n\n    # Calculate the score for proximity to maximum capacity\n    proximity_score = np.exp((bins - remaining_capacity) / bins)\n\n    # Calculate the reward for bins with item size close to the remaining capacity\n    size_reward = np.exp(-(remaining_capacity) / bins) * np.logical_not(item == remaining_capacity)\n\n    # Calculate the score for size\n    size_score = np.exp(item / remaining_capacity) + size_reward\n\n    # Calculate the proximity penalty for bins with less remaining capacity relative to their maximum capacity\n    proximity_penalty = np.exp((bins - remaining_capacity) / bins) - 1\n\n    # Calculate the final scores\n    scores = np.where(remaining_capacity >= item, 1e9,\n                     capacity_score + size_score + proximity_score - remaining_capacity_penalty + proximity_penalty)\n\n    return scores",
          "objective": 0.01197,
          "other_inf": null
     }
]