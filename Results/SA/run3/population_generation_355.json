[
     {
          "algorithm": "The new algorithm assigns a score to each bin based on the remaining capacity of the bin after assigning the item, multiplied by the inverse of the bin size. It also applies a penalty term to promote more efficient usage of bins, which is calculated as the square root of the inverse of the item size multiplied by the bin size, raised to the power of the remaining capacity divided by the bin size plus 1. The final scores are adjusted based on the inverse of the remaining capacity of the bin squared.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n    \n    # Calculate the inverse of the bin size\n    inverse_bin_size = 1 / bins\n    \n    # Calculate the penalty for more efficient usage of bins\n    penalty = (1 / np.sqrt(item * bins)) ** ((remaining_capacity / bins) + 1)\n    \n    # Calculate the adjusted score based on the remaining capacity and the penalty\n    adjusted_score = remaining_capacity * inverse_bin_size * penalty\n    \n    # Calculate the final scores, adjusting them based on the inverse of the remaining capacity of the bin squared\n    scores = np.where(remaining_capacity >= item, 1e9, adjusted_score / (remaining_capacity ** 2))\n    \n    return scores",
          "objective": 0.01358,
          "other_inf": null
     }
]