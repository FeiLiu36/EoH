[
     {
          "algorithm": "The new algorithm takes into account the remaining capacity and item size of each bin, but also introduces a penalty for bins with remaining capacities close to the maximum capacity, and rewards bins with item sizes close to the remaining capacity. The algorithm aims to balance the assignment of items to bins while minimizing the number of used bins.\n\nHere is the implementation of the new algorithm in Python:\n\n```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n\n    # Modified capacity score with additional penalty\n    capacity_penalty = np.exp(-(remaining_capacity - bins) / item) * np.logical_not(remaining_capacity == bins)\n    capacity_score = np.exp(-remaining_capacity / item) + capacity_penalty\n\n    # Penalty for bins with remaining capacity close to the maximum capacity\n    capacity_linear_difference_penalty = np.where(remaining_capacity == bins, bins - remaining_capacity, 0)\n\n    # Modified size score with additional reward\n    size_reward = np.exp((item - remaining_capacity) / bins) * np.logical_not(item == remaining_capacity)\n    size_score = np.exp(item / remaining_capacity) + size_reward\n\n    # Reward for bins with item size close to the remaining capacity\n    size_linear_difference_reward = np.where(item == remaining_capacity, item, 0)\n\n    # Calculate the final scores\n    scores = np.where(remaining_capacity >= item, np.full_like(remaining_capacity, 1e9),\n                     capacity_score + capacity_linear_difference_penalty +\n                     size_score + size_linear_difference_reward)\n\n    return scores",
          "objective": 0.01197,
          "other_inf": null
     }
]