[
     {
          "algorithm": "The new algorithm calculates the score for each bin by taking the square root of the bin index, multiplied by the square root of the remaining capacity ratio of the bin, and further multiplied by the logarithm of the bin index squared. It assigns maximum scores for bins with remaining capacity greater than or equal to the item size, and adjusts the scores based on the difference between the sum of the logarithm of the remaining capacity ratio and the bin index squared. The scores are then multiplied by the bin index squared, and a penalty is added to the scores for bins that have remaining capacity less than the item size and the remaining capacity ratio is less than or equal to 0.9.\n\nCode:\n``` ",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    max_capacity = np.max(bins)\n    remaining_capacity_ratio = remaining_capacity / max_capacity\n    \n    # Calculate the score for each bin\n    scores = np.sqrt(np.arange(len(bins), 0, -1)) * np.sqrt(remaining_capacity_ratio) * np.log(np.arange(len(bins), 0, -1))**2\n    \n    # Adjust the scores based on the difference between the sum of the logarithm of the remaining capacity ratio and the bin index squared\n    scores -= scores * (np.log(remaining_capacity_ratio) - np.power(np.arange(len(bins), 0, -1), 2))\n    \n    # Assign maximum scores for bins with remaining capacity >= item size\n    scores = np.where(remaining_capacity >= item, np.inf, scores)\n    \n    # Multiply scores by bin index squared\n    scores *= np.power(np.arange(len(bins)), 2)\n    \n    # Penalty for bins with remaining capacity less than item size and ratio <= 0.9\n    scores -= np.where((remaining_capacity < item) & (remaining_capacity_ratio <= 0.9), np.log(item), 0)\n    \n    return scores",
          "objective": 0.01157,
          "other_inf": null
     }
]