[
     {
          "algorithm": "The new algorithm calculates the score for each bin by taking the product of the reciprocal of the square root of the remaining capacity divided by the sum of the item size and the remaining capacity, the reciprocal of the cube root of the ratio between the remaining capacity and the maximum capacity raised to the power of the item size, and the reciprocal of the ratio between the remaining capacity and the maximum capacity raised to the power of the cube root of the item size, while also subtracting from it the cube root of the ratio between the remaining capacity and the maximum capacity raised to the power of the item size multiplied by the reciprocal of the remaining capacity multiplied by the item size, and multiplying it with the logarithm of the square root of the item size plus one.\n\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n\n    # Calculate the score for each bin\n    reciprocal1 = 1 / np.sqrt(remaining_capacity + item)\n    ratio_reciprocal = 1 / ((remaining_capacity / bins) ** item) ** (1/3)\n    ratio_power_reciprocal = 1 / ((remaining_capacity / bins) ** (item ** (1/3)))\n    sqrt_power = np.cbrt(np.cbrt(remaining_capacity / bins) ** item)\n    scores = reciprocal1 * ratio_reciprocal * ratio_power_reciprocal - (np.cbrt(sqrt_power) * (1 / remaining_capacity * item)) * np.log(np.sqrt(item) + 1)\n\n    # Assign maximum scores for bins with remaining capacity >= item size\n    scores = np.where(remaining_capacity >= item, np.inf, scores)\n\n    return scores",
          "objective": 0.01358,
          "other_inf": null
     }
]