[
     {
          "algorithm": "The new algorithm assigns a score to each bin based on the ratio of the remaining capacity of the bin to the bin size, multiplied by the logarithm of the inverse of the bin size. It also applies a penalty term to promote more efficient usage of bins, which is calculated as the logarithm of the product of the inverse of the item size and the bin size, raised to the power of the remaining capacity divided by the bin size plus 1. The final scores are adjusted based on the inverse of the remaining capacity of the bin squared, with a modified adjustment value of 2, to promote even lower scores for bins with higher remaining capacity.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n    \n    # Calculate the ratio of remaining capacity to bin size\n    capacity_ratio = remaining_capacity / bins\n    \n    # Calculate the logarithm of the inverse bin size\n    log_inverse_bin_size = np.log(1 / bins)\n    \n    # Calculate the penalty term for more efficient usage of bins\n    penalty = np.log((1 / item) * bins) ** ((remaining_capacity / bins) + 1)\n    \n    # Calculate the adjusted score based on the capacity ratio, log inverse bin size, and penalty\n    adjusted_score = capacity_ratio * log_inverse_bin_size * penalty\n    \n    # Calculate the final scores, adjusting them based on the inverse of the remaining capacity of the bin squared with a modified adjustment value of 2\n    scores = np.where(remaining_capacity >= item, 1e9, (adjusted_score / (remaining_capacity ** 2)) ** 2)\n    \n    return scores",
          "objective": 0.01358,
          "other_inf": null
     }
]