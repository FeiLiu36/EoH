[
     {
          "algorithm": "# New algorithm description:\nThe new algorithm assigns a score to each bin based on a combination of factors that include the remaining capacity of the bin, the ratio between the item size and the remaining capacity, and a penalty term for penalizing bins with higher remaining capacity. The final score is calculated using these factors and is adjusted based on the remaining capacity of the bin. Additionally, the algorithm incorporates a new factor that takes into account the ratio between the remaining capacity and the item size, aiming to minimize the number of used bins by favoring bins with higher remaining capacity relative to the item size.\n\n# New code implementation:\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n\n    # Calculate the ratio between the item size and the remaining capacity\n    size_ratio = item / remaining_capacity\n\n    # Calculate the penalty for bins with higher remaining capacity\n    penalty = np.exp(-size_ratio)\n\n    # Calculate the factor based on remaining capacity\n    factor = np.exp(size_ratio)\n\n    # Calculate the new factor based on the ratio between the remaining capacity and the item size\n    new_factor = np.exp(-remaining_capacity/item)\n\n    # Calculate the adjusted score based on the factors, including the new factor\n    adjusted_score = remaining_capacity * (size_ratio + penalty) * factor * new_factor\n\n    # Calculate the final scores\n    scores = np.where(remaining_capacity >= item, 1e9, adjusted_score)\n\n    return scores",
          "objective": 0.01217,
          "other_inf": null
     }
]