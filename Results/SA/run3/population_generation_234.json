[
     {
          "algorithm": "The new algorithm assigns scores to bins based on a modified version of the original algorithm. It considers the remaining capacity and item size of each bin, but also introduces a penalty for bins with remaining capacities close to the maximum capacity, and rewards bins with item sizes close to the remaining capacity. The algorithm aims to balance the assignment of items to bins while minimizing the number of used bins.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n\n    capacity_score = np.exp(-remaining_capacity / item) + np.exp(-(remaining_capacity - bins) / item) # Modified capacity score with additional penalty\n    capacity_linear_difference = np.maximum(remaining_capacity - item, 0)\n    capacity_linear_difference_penalty = np.where(remaining_capacity == bins, bins - remaining_capacity, 0) # Penalty for bins with remaining capacity close to the maximum capacity\n\n    size_score = np.exp(item / remaining_capacity) + np.exp(item / (remaining_capacity - bins)) # Modified size score with additional reward\n    size_linear_difference = np.maximum(item - remaining_capacity, 0)\n    size_linear_difference_reward = np.where(item == remaining_capacity, item, 0) # Reward for bins with item size close to the remaining capacity\n\n    scores = np.where(remaining_capacity >= item, np.full_like(remaining_capacity, 1e9),\n                     capacity_score + capacity_linear_difference + capacity_linear_difference_penalty +\n                     size_score + size_linear_difference + size_linear_difference_reward)\n\n    return scores",
          "objective": 0.01197,
          "other_inf": null
     }
]