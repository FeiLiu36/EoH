[
     {
          "algorithm": "New Algorithm Description: The new algorithm assigns a score to each bin based on a combination of factors including the remaining capacity, item size, and penalty terms. It penalizes bins with lower remaining capacity than the item size and also penalizes bins with less remaining capacity relative to their maximum capacity. The algorithm aims to maximize the score for bins that have more available capacity, closer proximity to their maximum capacity, and are closer in size to the remaining capacity of the bin.\n\nHere is the implementation of the new algorithm:\n\n```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n\n    # Calculate the penalty for bins with lower remaining capacity than the item size\n    remaining_capacity_penalty = np.exp(-remaining_capacity / item) - 1\n    \n    # Calculate the penalty for bins with less remaining capacity relative to their maximum capacity\n    proximity_penalty = np.exp((bins - remaining_capacity) / bins) - 1\n    \n    # Calculate the score for capacity based on remaining capacity and penalties\n    capacity_score = np.exp(-(item - remaining_capacity) / item) - remaining_capacity_penalty + proximity_penalty\n    \n    # Calculate the reward for bins with item size close to the remaining capacity\n    size_reward = np.exp(-np.abs(item - remaining_capacity) / bins) * np.logical_not(item == remaining_capacity)\n    \n    # Calculate the score for size based on item size, remaining capacity and size reward\n    size_score = np.exp(item / remaining_capacity) + size_reward\n    \n    # Calculate the final scores\n    scores = np.where(remaining_capacity >= item, 1e9,\n                     capacity_score + size_score)\n    \n    return scores",
          "objective": 0.01197,
          "other_inf": null
     }
]