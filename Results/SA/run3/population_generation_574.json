[
     {
          "algorithm": "Algorithm Description: The new algorithm calculates the score for each bin based on a modified formula by adding a quadratic term to the original algorithm: score = (sqrt(remaining_capacity) / item) * ((1 / (log(remaining_capacity) * remaining_capacity)) + 1) * (exp(remaining_capacity) / item) * (remaining_capacity / item) * (remaining_capacity / (np.exp(item) + 1)) + ((remaining_capacity**2) / item)\n\nCode:\n\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n\n    # Calculate the square root of the remaining capacity\n    sqrt_remaining_capacity = np.sqrt(remaining_capacity)\n\n    # Calculate the reciprocal of the natural logarithm of the remaining capacity multiplied by the remaining capacity and add 1\n    log_ratio = 1 / (np.log(remaining_capacity) * remaining_capacity) + 1\n\n    # Calculate the exponent of the remaining capacity\n    capacity_exp = np.exp(remaining_capacity)\n\n    # Calculate the reciprocal of the item size\n    item_reciprocal = 1 / item\n\n    # Calculate the product of the square root, modified reciprocal, exponent, remaining capacity divided by item size, and remaining capacity divided by (exp(item) + 1)\n    weighted_product = sqrt_remaining_capacity * log_ratio * (capacity_exp * item_reciprocal) * (remaining_capacity / item) * (remaining_capacity / (np.exp(item) + 1))\n\n    # Add quadratic term to the scores\n    scores_step7 = weighted_product * item_reciprocal + ((remaining_capacity**2) / item)\n\n    # Assign maximum scores for bins with remaining capacity >= item size\n    scores_step8 = np.where(remaining_capacity >= item, np.inf, scores_step7)\n\n    # Multiply scores with mask to make scores of unused bins equal to 0\n    scores = scores_step8 * (1 - np.where(remaining_capacity == bins, 1, 0))\n\n    return scores",
          "objective": 0.01157,
          "other_inf": null
     }
]