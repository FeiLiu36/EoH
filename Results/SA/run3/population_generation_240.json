[
     {
          "algorithm": "The new algorithm calculates the score for each bin based on the remaining capacity and item size, as well as the proximity to maximum capacity and remaining capacity. The algorithm aims to optimize the assignment of items to bins while minimizing the number of used bins.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n\n    # Calculate the penalty for bins with remaining capacity close to the maximum capacity\n    capacity_penalty = np.exp(-(remaining_capacity - bins) / item) * np.logical_not(remaining_capacity == bins)\n\n    # Calculate the score for capacity\n    capacity_score = np.exp(-remaining_capacity / item) + capacity_penalty\n\n    # Calculate the reward for bins with item size close to the remaining capacity\n    size_reward = np.exp((item - remaining_capacity) / bins) * np.logical_not(item == remaining_capacity)\n\n    # Calculate the score for size\n    size_score = np.exp(item / remaining_capacity) + size_reward\n\n    # Calculate the final scores\n    scores = np.where(remaining_capacity >= item, np.full_like(remaining_capacity, 1e9),\n                     capacity_score + size_score)\n\n    return scores",
          "objective": 0.01197,
          "other_inf": null
     }
]