[
     {
          "algorithm": "The new algorithm aims to assign items to bins based on the ratio of the item size to the remaining capacity, considering various factors such as the logarithm of the ratio, the square root of the sum of squares between the remaining capacity and the bin size, the inverse of the scaled remaining capacity, and the maximum remaining capacity among the bins.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n\n    # Step 1: Create mask for maximum capacity bins\n    mask_max_capacity = np.where(remaining_capacity == bins, 1, 0)\n\n    # Step 2: Calculate ratio of item size to remaining capacity\n    capacity_ratio = item / remaining_capacity\n\n    # Step 3: Calculate logarithm of the ratio between bin size and item size\n    size_ratio_log = np.log(bins / item)\n\n    # Step 4: Calculate square root of the sum of squares of remaining capacity and bin size\n    size_inverse_root = 1 / np.sqrt(np.power(remaining_capacity, 2) + np.power(bins, 2))\n\n    # Step 5: Calculate inverse of scaled remaining capacity\n    scaled_remaining_capacity_inverse = 1 / remaining_capacity\n\n    # Step 6: Calculate ratio of item size to maximum remaining capacity\n    max_capacity_ratio = item / np.max(remaining_capacity)\n\n    # Step 7: Calculate product of the factors\n    weighted_product = capacity_ratio * size_ratio_log * size_inverse_root * scaled_remaining_capacity_inverse * max_capacity_ratio\n\n    # Step 8: Assign maximum scores for bins with remaining capacity >= item size\n    scores_step8 = np.where(remaining_capacity >= item, 1e9, weighted_product)\n\n    # Step 9: Multiply scores with mask to make scores of unused bins equal to 0\n    scores = scores_step8 * (1 - mask_max_capacity)\n\n    return scores",
          "objective": 0.01358,
          "other_inf": null
     }
]