[
     {
          "algorithm": "The new algorithm assigns a base score to each bin by multiplying the remaining capacity divided by the item size by a constant factor of 1000. It then subtracts the logarithm of the item size divided by the remaining capacity multiplied by another constant factor of 1000. It adds a penalty score to each bin based on the ratio of the item size to the remaining capacity, multiplied by a constant factor of 1000. Finally, it sets the scores of bins that cannot accommodate the item to infinity.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n    base_scores = (remaining_capacity / item) * 1000 - (np.log(item) / remaining_capacity) * 1000\n    penalty_scores = (item / remaining_capacity) * 1000\n    scores = base_scores + penalty_scores\n    scores = np.where(remaining_capacity >= item, np.full_like(scores, np.inf), scores)\n    return scores",
          "objective": 0.01358,
          "other_inf": null
     }
]