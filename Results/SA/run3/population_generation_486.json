[
     {
          "algorithm": "Algorithm description: The new algorithm is based on the formula: score = exp(remaining_capacity) * sqrt(item/remaining_capacity) * log(item/remaining_capacity) * (exp(remaining_capacity)/item) * (remaining_capacity/sum(bins)^2). The main steps of the algorithm are as follows:\n\n1. Calculate the remaining capacity for each bin by subtracting the item size from the rest capacities of the bins.\n2. Calculate the ratio of the item size to the remaining capacity.\n3. Calculate the square root of the ratio of item size to remaining capacity.\n4. Calculate the logarithm of the ratio of item size to remaining capacity.\n5. Calculate the exponent of the remaining capacity.\n6. Calculate the exponent of the remaining capacity and divide by the item size.\n7. Calculate the ratio of the remaining capacity to the sum of the bin sizes squared.\n8. Calculate the product of all the factors.\n9. Assign maximum scores for bins with remaining capacity greater than or equal to the item size.\n10. Multiply the scores with a mask to make scores of unused bins equal to 0.\n\nHere's the implementation of the modified algorithm in Python:\n\n```python\nimport numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n\n    # Calculate ratio of item size to remaining capacity\n    capacity_ratio = item / remaining_capacity\n\n    # Calculate square root of the ratio of item size to remaining capacity\n    capacity_sqrt_ratio = np.sqrt(capacity_ratio)\n\n    # Calculate logarithm of ratio of item size to remaining capacity\n    ratio_log = np.log(capacity_ratio)\n\n    # Calculate exponent of remaining capacity\n    capacity_exp = np.exp(remaining_capacity)\n\n    # Calculate exponent of remaining capacity and divide by item size\n    capacity_exp_ratio = np.exp(remaining_capacity) / item\n\n    # Calculate ratio of remaining capacity to the sum of the bin sizes squared\n    capacity_sum_ratio_squared = remaining_capacity / np.sum(bins)**2\n\n    # Calculate the product of all the factors\n    weighted_product = capacity_exp * capacity_sqrt_ratio * ratio_log * capacity_exp_ratio * capacity_sum_ratio_squared\n\n    # Assign maximum scores for bins with remaining capacity >= item size\n    scores_step10 = np.where(remaining_capacity >= item, np.inf, weighted_product)\n\n    # Multiply scores with mask to make scores of unused bins equal to 0\n    scores = scores_step10 * (1 - np.where(remaining_capacity == bins, 1, 0))\n\n    return scores\n```\n\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n\n    # Calculate ratio of item size to remaining capacity\n    capacity_ratio = item / remaining_capacity\n\n    # Calculate square root of the ratio of item size to remaining capacity\n    capacity_sqrt_ratio = np.sqrt(capacity_ratio)\n\n    # Calculate logarithm of ratio of item size to remaining capacity\n    ratio_log = np.log(capacity_ratio)\n\n    # Calculate exponent of remaining capacity\n    capacity_exp = np.exp(remaining_capacity)\n\n    # Calculate exponent of remaining capacity and divide by item size\n    capacity_exp_ratio = np.exp(remaining_capacity) / item\n\n    # Calculate ratio of remaining capacity to the sum of the bin sizes squared\n    capacity_sum_ratio_squared = remaining_capacity / np.sum(bins)**2\n\n    # Calculate the product of all the factors\n    weighted_product = capacity_exp * capacity_sqrt_ratio * ratio_log * capacity_exp_ratio * capacity_sum_ratio_squared\n\n    # Assign maximum scores for bins with remaining capacity >= item size\n    scores_step10 = np.where(remaining_capacity >= item, np.inf, weighted_product)\n\n    # Multiply scores with mask to make scores of unused bins equal to 0\n    scores = scores_step10 * (1 - np.where(remaining_capacity == bins, 1, 0))\n\n    return scores",
          "objective": 0.01459,
          "other_inf": null
     }
]