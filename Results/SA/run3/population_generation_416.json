[
     {
          "algorithm": "The new algorithm calculates the score for each bin based on the following steps:\n1. Create a mask where the rest capacity of a bin equals the maximum capacity by comparing it with the maximum capacity.\n2. Calculate the inverse of the ratio between the remaining capacity and the bin size, raised to the power of 0.7, for all the bins.\n3. Calculate the inverse of the logarithm of the item size for all the bins.\n4. Calculate the inverse of the scaled value of the remaining capacity with a scaling factor of 1,000, raised to the power of 0.8, for all the bins.\n5. Calculate the inverse of the square root of the sum of squares of the remaining capacity and bin size, raised to the power of 0.6, for all the bins.\n6. Create a mask where the remaining capacity is less than the item size by comparing it with the item size.\n7. Calculate the product of the four factors for all the bins.\n8. Assign a maximum score of 1e9 for the bins where the remaining capacity is greater than or equal to the item size.\n9. Multiply the weighted product with the mask created in step 1 to make the scores of unused bins equal to 0.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n    \n    # Step 1: Create mask for maximum capacity bins\n    mask_max_capacity = np.where(remaining_capacity == bins, 1, 0)\n    \n    # Step 2: Calculate inverse of ratio between remaining capacity and bin size\n    capacity_ratio_inverse = 1 / np.power(remaining_capacity / bins, 0.7)\n    \n    # Step 3: Calculate inverse of logarithm of item size\n    item_size_inverse = 1 / np.log(item)\n    \n    # Step 4: Calculate inverse of scaled remaining capacity\n    scaled_remaining_capacity_inverse_pow_0_8 = 1 / np.power(remaining_capacity/1000, 0.8)\n    \n    # Step 5: Calculate inverse of square root of sum of squares of remaining capacity and bin size\n    size_inverse_pow_0_6 = 1 / np.power(np.sqrt(np.power(remaining_capacity, 2) + np.power(bins, 2)), 0.6)\n    \n    # Step 6: Create mask for remaining capacity less than item size\n    mask_remaining_capacity = np.where(remaining_capacity < item, 1, 0)\n    \n    # Step 7: Calculate product of the four factors\n    weighted_product = capacity_ratio_inverse * item_size_inverse * scaled_remaining_capacity_inverse_pow_0_8 * size_inverse_pow_0_6\n    \n    # Step 8: Assign maximum scores for bins with remaining capacity >= item size\n    scores_step8 = np.where(remaining_capacity >= item, 1e9, weighted_product)\n    \n    # Step 9: Multiply scores with mask to make scores of unused bins equal to 0\n    scores = scores_step8 * (1 - mask_max_capacity)\n    \n    return scores",
          "objective": 0.01358,
          "other_inf": null
     }
]