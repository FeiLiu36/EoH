[
     {
          "algorithm": "New algorithm description: The new algorithm calculates the scores for each bin based on the remaining capacity of the bins, the number of items already assigned to the bins, and a penalty for bins with remaining capacity below a threshold ratio. It incorporates a logarithmic function of the bin index multiplied by the number of items assigned plus one and a power factor of the ratio between the remaining capacity and item size, divided by the bin index plus one. It also introduces a new step where the scores are multiplied by the square root of the logarithm of the bin indices to further promote performance. The new algorithm also includes an additional step where the scores are divided by the inverse of the bin index squared to enhance the prioritization of smaller bin indices.\n\nNew algorithm code:\n\n```",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    num_items_assigned = np.count_nonzero(remaining_capacity < bins)\n    max_capacity = np.max(bins)\n    bin_indices = np.arange(len(bins)) + 1\n\n    remaining_capacity_ratio = remaining_capacity / max_capacity\n    num_items_assigned_ratio = (num_items_assigned + 1) / (bins.size + 1)\n\n    scores = (remaining_capacity_ratio * num_items_assigned_ratio *\n              (1 + np.log(bin_indices)) /\n              np.sqrt(remaining_capacity * np.log(remaining_capacity)))\n\n    scores -= remaining_capacity_ratio - np.sqrt(bin_indices)\n\n    scores = np.where(remaining_capacity >= item, np.inf, scores)\n    scores *= (bin_indices * (num_items_assigned + 1))\n\n    threshold_ratio = 0.4\n\n    # New step: Assign a penalty score to bins with remaining capacity below the threshold ratio\n    penalization_factor = np.where(remaining_capacity_ratio < threshold_ratio,\n                                   np.exp(-remaining_capacity_ratio / threshold_ratio), 1)\n    scores *= penalization_factor\n\n    # Additional step: Divide scores by the inverse of the bin index squared\n    scores /= (1 / bin_indices)**2\n\n    # Modified step: Multiply scores by the logarithmic function of the bin index multiplied by the number of items assigned plus one\n    log_factor = np.log(bin_indices) * (num_items_assigned + 1)\n    scores *= log_factor\n\n    # Modified step: Multiply scores by the power factor of the ratio between remaining capacity and item size, divided by the bin index plus one\n    power_factor = (remaining_capacity / item) ** (1 / (bin_indices + 1))\n    scores *= power_factor\n\n    # New step: Multiply scores by the square root of the logarithm of the bin indices\n    scores *= np.sqrt(np.log(bin_indices))\n\n    return scores",
          "objective": 0.00976,
          "other_inf": null
     }
]