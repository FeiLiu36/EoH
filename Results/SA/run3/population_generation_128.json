[
     {
          "algorithm": "\nThe new algorithm assigns a base score to each bin by taking the square root of the remaining capacity divided by the item size, multiplying it by a constant factor of 1000, and subtracting the item size divided by the square root of the remaining capacity multiplied by another constant factor of 1000. It then adds a penalty score to each bin based on the ratio of the item size to the remaining capacity, multiplied by a constant factor of 1000. Finally, it sets the scores of bins that cannot accommodate the item to infinity.\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n    base_scores = (np.sqrt(remaining_capacity) / item) * 1000 - (item / np.sqrt(remaining_capacity)) * 1000\n    penalty_scores = (item / remaining_capacity) * 1000\n    scores = base_scores + penalty_scores\n    scores = np.where(remaining_capacity >= item, np.full_like(scores, np.inf), scores)\n    return scores",
          "objective": 0.01529,
          "other_inf": null
     }
]