[
     {
          "algorithm": "The new algorithm assigns scores to each bin based on a combination of the remaining capacity ratio, the bin index, and an adjustment factor. First, it calculates the remaining capacity ratio for each bin by dividing the remaining capacity by the maximum capacity. Then, it calculates the score by taking the product of the remaining capacity ratio and the inverse of the bin index, divided by the square root of the remaining capacity, and multiplied by the logarithm of the remaining capacity. Next, it adjusts the scores based on the difference between the remaining capacity ratio and the square root of the bin index. It assigns maximum scores to bins with remaining capacity greater than or equal to the item size. The scores are then multiplied by the bin index, and a penalty is added to the scores for bins with remaining capacity less than the item size and for bins with a remaining capacity ratio below a certain threshold ratio.",
          "code": "import numpy as np\n\ndef score(item: int, bins: np.ndarray) -> np.ndarray:\n    remaining_capacity = bins - item\n    max_capacity = np.max(bins)\n    remaining_capacity_ratio = remaining_capacity / max_capacity\n    scores = (remaining_capacity_ratio * (1 / np.sqrt(np.arange(len(bins)) + 1))) / np.sqrt(remaining_capacity * np.log(remaining_capacity))\n    scores -= (remaining_capacity_ratio - np.sqrt(np.arange(len(bins)) + 1))\n    scores = np.where(remaining_capacity >= item, np.inf, scores)\n    scores *= np.arange(len(bins)) + 1\n    scores -= np.where(remaining_capacity < item, np.log(item), 0)\n    threshold_ratio = 0.5\n    scores -= np.where(remaining_capacity_ratio < threshold_ratio, np.log(1 + threshold_ratio - remaining_capacity_ratio), 0)\n    return scores",
          "objective": 0.00946,
          "other_inf": null
     }
]