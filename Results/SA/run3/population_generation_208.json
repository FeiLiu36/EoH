[
     {
          "algorithm": "The new algorithm calculates the scores for each bin based on a combination of polynomial and exponential functions, which assign higher scores to bins with less remaining capacity and larger item sizes while penalizing bins with more remaining capacity and smaller item sizes. The algorithm also introduces a new term that penalizes bins with extreme differences between the remaining capacity and item size. In addition, the new algorithm further penalizes bins with extremely low remaining capacity or extremely large item sizes.\n\nCode:\n\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n    \n    capacity_ratio = np.polyval([200, 0], np.exp(-(remaining_capacity / item)**2))\n    capacity_log_difference = np.abs(np.polyval([3, 0], np.log(remaining_capacity / item)))\n    capacity_difference_penalty = np.maximum(((remaining_capacity - item) / item)**2, 0)\n    \n    size_ratio = np.polyval([10, 0], np.exp(-(item / remaining_capacity)**2))\n    size_log_difference = np.abs(np.polyval([1, 0], np.log(item / remaining_capacity)))\n    size_difference_penalty = np.maximum(((item - remaining_capacity) / remaining_capacity)**2, 0)\n    \n    scores = np.where(remaining_capacity >= item, np.full_like(remaining_capacity, 1e9), \n                     np.maximum(capacity_ratio, capacity_log_difference) + capacity_difference_penalty +\n                     np.maximum(size_ratio, size_log_difference) + size_difference_penalty)\n    \n    scores = np.round(scores)\n    \n    return scores",
          "objective": 0.01358,
          "other_inf": null
     }
]