[
     {
          "algorithm": "The new algorithm assigns items to bins based on the ratio of the item size to the remaining capacity, considering factors such as the exponential of the inverse of the ratio, the square root of the sum of squares between the remaining capacity and the bin size, the logarithm of the ratio between the maximum remaining capacity and the item size, and the square of the ratio between the bin size and the item size, while also taking into account the ratio between the remaining capacity and the sum of the bin sizes, and the inverse of the scaled remaining capacity.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n\n    # Step 1: Create mask for maximum capacity bins\n    mask_max_capacity = np.where(remaining_capacity == bins, 1, 0)\n\n    # Step 2: Calculate ratio of item size to remaining capacity\n    capacity_ratio = item / remaining_capacity\n\n    # Step 3: Calculate exponential of the inverse of the ratio\n    inverse_ratio_exp = np.exp(1 / capacity_ratio)\n\n    # Step 4: Calculate square root of the sum of squares of remaining capacity and bin size\n    size_inverse_root = 1 / np.sqrt(np.power(remaining_capacity, 2) + np.power(bins, 2))\n\n    # Step 5: Calculate logarithm of the ratio between maximum remaining capacity and item size\n    max_capacity_ratio_log = np.log(np.max(remaining_capacity) / item)\n\n    # Step 6: Calculate square of the ratio between bin size and item size\n    size_ratio_square = np.power(bins / item, 2)\n\n    # Step 7: Calculate ratio of remaining capacity to sum of bin sizes\n    capacity_sum_ratio = remaining_capacity / np.sum(bins)\n\n    # Step 8: Calculate inverse of scaled remaining capacity\n    scaled_remaining_capacity_inverse = 1 / remaining_capacity\n\n    # Step 9: Calculate product of the factors\n    weighted_product = inverse_ratio_exp * size_inverse_root * max_capacity_ratio_log * size_ratio_square * capacity_sum_ratio * scaled_remaining_capacity_inverse\n\n    # Step 10: Assign maximum scores for bins with remaining capacity >= item size\n    scores_step10 = np.where(remaining_capacity >= item, 1e9, weighted_product)\n\n    # Step 11: Multiply scores with mask to make scores of unused bins equal to 0\n    scores = scores_step10 * (1 - mask_max_capacity)\n\n    return scores",
          "objective": 0.01358,
          "other_inf": null
     }
]