[
     {
          "algorithm": "The new algorithm calculates the score for each bin by taking the square root of the ratio of the remaining capacity to the bin size, multiplied by the square root of the bin size divided by the sum of the item size and the bin size. The scores are then adjusted based on the inverse of the remaining capacity of the bin squared, with a modified adjustment value of 2, to promote lower scores for bins with higher remaining capacity.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n    \n    # Calculate the ratio of remaining capacity to bin size\n    capacity_ratio = np.sqrt(remaining_capacity / bins)\n    \n    # Calculate the penalty term for more efficient usage of bins\n    penalty = np.sqrt(bins) / (item + bins)\n    \n    # Calculate the product of the remaining capacity ratio and the penalty term\n    weighted_product = capacity_ratio * penalty\n    \n    # Calculate the final scores, adjusting them based on the inverse of the remaining capacity of the bin squared with a modified adjustment value of 2\n    scores = np.where(remaining_capacity >= item, 1e9, (weighted_product / (remaining_capacity ** 2)) ** 2)\n    \n    return scores",
          "objective": 0.01358,
          "other_inf": null
     }
]