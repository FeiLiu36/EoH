[
     {
          "algorithm": "Algorithm:\n\nThe new algorithm aims to update the edge distance matrix by considering the local optimal tour and the ratio of the total number of permutations to the number of times each edge is used, but with a different parameter setting of the score function.\n\n```Python\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    # Create a copy of the edge distance and edge used matrices\n    updated_edge_distance = np.copy(edge_distance)\n    updated_edge_n_used = np.copy(edge_n_used)\n    \n    # Get the number of nodes in the tour\n    num_nodes = len(local_opt_tour)\n    total_permutations = num_nodes * (num_nodes - 1)\n    \n    # Iterate over each node in the tour\n    for i in range(num_nodes):\n        # Get the current node ID and the next node ID\n        current_node = local_opt_tour[i]\n        next_node = local_opt_tour[(i + 1) % num_nodes]  # Wrap around to the first node if at the last node\n        \n        # Compute the score for updating the edge distance\n        score = (total_permutations - edge_n_used[current_node, next_node]) / (edge_n_used[current_node, next_node] + 1)\n        \n        # Update the edge distance between the current and next node\n        updated_edge_distance[current_node, next_node] = edge_distance[current_node, next_node] + score\n        \n        # Update the edge distance between the next and current node\n        updated_edge_distance[next_node, current_node] = edge_distance[next_node, current_node] + score\n        \n        # Update the number of times the edge is used\n        updated_edge_n_used[current_node, next_node] += 1\n        updated_edge_n_used[next_node, current_node] += 1\n    \n    return updated_edge_distance",
          "objective": 0.03859,
          "other_inf": null
     },
     {
          "algorithm": "New Algorithm: The modified algorithm updates the edge distance matrix by increasing the distances of the edges used in the local optimal tour. The increase in distance is based on the number of times each edge is used during permutation, with a higher increase for edges used less frequently, using a different parameter settings of the score function.\n\nPython code:\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        edge_n_used_normalized = edge_n_used[edge] / np.max(edge_n_used)\n        edge_distance_increase = 1 + 0.01 / edge_n_used_normalized\n        updated_edge_distance[edge] += edge_distance_increase\n    return updated_edge_distance",
          "objective": 0.09324,
          "other_inf": null
     },
     {
          "algorithm": "New Algorithm: The modified algorithm updates the edge distance matrix by increasing the distances of the edges used in the local optimal tour. The increase in distance is based on the number of times each edge is used during permutation, with a higher increase for edges used less frequently, using a different parameter settings of the score function.\nAlgorithm parameters:\n- edge_distance: a matrix representing the distances between edges.\n- local_opt_tour: a numpy array representing the local optimal tour of IDs.\n- edge_n_used: a matrix representing the number of times each edge is used during permutation.\n\nPython code:\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        edge_n_used_normalized = edge_n_used[edge] / np.max(edge_n_used)\n        edge_distance_increase = 1 + 0.02 / edge_n_used_normalized  # Different parameter setting, increase factor of 0.02\n        updated_edge_distance[edge] += edge_distance_increase\n    return updated_edge_distance",
          "objective": 0.09435,
          "other_inf": null
     },
     {
          "algorithm": "New Algorithm: The modified algorithm updates the edge distance matrix by increasing the distances of the edges used in the local optimal tour. The increase in distance is based on the number of times each edge is used during permutation, with a higher increase for edges used less frequently, using a different parameter settings of the score function.\nThe new algorithm will use a different parameter setting for the edge distance increase factor. Instead of the current factor of 0.02, we will use a factor of 0.05. The updated edge distance increase will be calculated as 1 + 0.05 / edge_n_used_normalized.\n\nHere is the updated Python implementation of the function:\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        edge_n_used_normalized = edge_n_used[edge] / np.max(edge_n_used)\n        edge_distance_increase = 1 + 0.05 / edge_n_used_normalized  # Different parameter setting, increase factor of 0.05\n        updated_edge_distance[edge] += edge_distance_increase\n    return updated_edge_distance",
          "objective": 0.09892,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm: The new algorithm aims to update the edge distance matrix by considering the local optimal tour and the ratio of the number of times each edge is used to the total number of permutations, but with a different parameter setting of the score function.\n\nUpdated code:\n\n```",
          "code": "def update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    # Create a copy of the edge distance and edge used matrices\n    updated_edge_distance = np.copy(edge_distance)\n    updated_edge_n_used = np.copy(edge_n_used)\n    \n    # Get the number of nodes in the tour\n    num_nodes = len(local_opt_tour)\n    total_permutations = num_nodes * (num_nodes - 1)\n    \n    # Iterate over each node in the tour\n    for i in range(num_nodes):\n        # Get the current node ID and the next node ID\n        current_node = local_opt_tour[i]\n        next_node = local_opt_tour[(i + 1) % num_nodes]  # Wrap around to the first node if at the last node\n        \n        # Update the edge distance between the current and next node\n        updated_edge_distance[current_node, next_node] = edge_distance[current_node, next_node] + 1 / edge_n_used[current_node, next_node]\n        \n        # Update the edge distance between the next and current node\n        updated_edge_distance[next_node, current_node] = edge_distance[next_node, current_node] + 1 / edge_n_used[next_node, current_node]\n        \n        # Update the number of times the edge is used\n        updated_edge_n_used[current_node, next_node] += 1\n        updated_edge_n_used[next_node, current_node] += 1\n    \n    return updated_edge_distance",
          "objective": 0.13822,
          "other_inf": null
     },
     {
          "algorithm": "New Algorithm: The modified algorithm updates the edge distance matrix by increasing the distances of the edges used in the local optimal tour. The increase in distance is based on the number of times each edge is used during permutation, with a higher increase for edges used less frequently.\n\nPython code:\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        edge_distance_increase = 1 + 0.1 / edge_n_used[edge]\n        updated_edge_distance[edge] += edge_distance_increase\n    return updated_edge_distance",
          "objective": 0.15783,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm description: The new algorithm updates the edge distance matrix by adding a penalty to the edges that are frequently used in the local optimal tour, but the penalty is proportional to the square root of the number of times the edge is used, making it harder for frequently used edges to accumulate penalties. \n\nCode:\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        edge_n_used[edge] += 1\n        \n    for i in range(len(updated_edge_distance)):\n        for j in range(len(updated_edge_distance)):\n            if edge_n_used[(i, j)] != 0:\n                penalty = 1 / np.sqrt(edge_n_used[(i, j)])\n                updated_edge_distance[i][j] += penalty\n    \n    return updated_edge_distance",
          "objective": 0.18891,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm: The new algorithm aims to update the edge distance matrix by considering the local optimal tour and the ratio of the number of times each edge is used to the total number of permutations, but with a different parameter setting of the score function.\n\nCode:\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    # Create a copy of the edge distance and edge used matrices\n    updated_edge_distance = np.copy(edge_distance)\n    updated_edge_n_used = np.copy(edge_n_used)\n    \n    # Get the number of nodes in the tour\n    num_nodes = len(local_opt_tour)\n    total_permutations = num_nodes * (num_nodes - 1)\n    \n    # Iterate over each node in the tour\n    for i in range(num_nodes):\n        # Get the current node ID and the next node ID\n        current_node = local_opt_tour[i]\n        next_node = local_opt_tour[(i + 1) % num_nodes]  # Wrap around to the first node if at the last node\n        \n        # Update the edge distance between the current and next node\n        updated_edge_distance[current_node, next_node] = edge_distance[current_node, next_node] + 1 / (edge_n_used[current_node, next_node] + 1)\n        \n        # Update the edge distance between the next and current node\n        updated_edge_distance[next_node, current_node] = edge_distance[next_node, current_node] + 1 / (edge_n_used[next_node, current_node] + 1)\n        \n        # Update the number of times the edge is used\n        updated_edge_n_used[current_node, next_node] += 1\n        updated_edge_n_used[next_node, current_node] += 1\n    \n    return updated_edge_distance",
          "objective": 0.19925,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm description: The new algorithm penalizes the edges used in the local optimal tour based on their number of times used and adjusts their distance values accordingly to encourage exploration of different routes and prevent being trapped in the local optimum. However, in this new algorithm, the constant_value is set to 15 instead of 10.\n\nNew algorithm code:\n\n```\n",
          "code": "import numpy as np\nimport math\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n  \n    constant_value = 15  # Constant value to be subtracted/added to the current distance value\n  \n    for i in range(len(local_opt_tour) - 1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n      \n        edge_n_used[edge[0], edge[1]] += 1\n        edge_n_used[edge[1], edge[0]] += 1\n      \n        updated_edge_distance[edge[0], edge[1]] -= constant_value * math.log(edge_distance[edge[0], edge[1]]) * edge_n_used[edge[0], edge[1]] + constant_value * math.log(edge_n_used[edge[0], edge[1]])\n        updated_edge_distance[edge[1], edge[0]] -= constant_value * math.log(edge_distance[edge[1], edge[0]]) * edge_n_used[edge[1], edge[0]] + constant_value * math.log(edge_n_used[edge[1], edge[0]])\n      \n    return updated_edge_distance",
          "objective": 0.20855,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm: The new algorithm aims to update the edge distance matrix by considering the local optimal tour and the ratio of the number of times each edge is used to the total number of permutations, with a higher weight factor for the score function.\n\nCode:\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    # Create a copy of the edge distance and edge used matrices\n    updated_edge_distance = np.copy(edge_distance)\n    updated_edge_n_used = np.copy(edge_n_used)\n    \n    # Get the number of nodes in the tour\n    num_nodes = len(local_opt_tour)\n    total_permutations = num_nodes * (num_nodes - 1)\n    \n    # Set the weight factor for the score function\n    weight_factor = 0.75\n    \n    # Iterate over each node in the tour\n    for i in range(num_nodes):\n        # Get the current node ID and the next node ID\n        current_node = local_opt_tour[i]\n        next_node = local_opt_tour[(i + 1) % num_nodes]  # Wrap around to the first node if at the last node\n        \n        # Update the edge distance between the current and next node\n        updated_edge_distance[current_node, next_node] = edge_distance[current_node, next_node] + weight_factor / edge_n_used[current_node, next_node]\n        \n        # Update the edge distance between the next and current node\n        updated_edge_distance[next_node, current_node] = edge_distance[next_node, current_node] + weight_factor / edge_n_used[next_node, current_node]\n        \n        # Update the number of times the edge is used\n        updated_edge_n_used[current_node, next_node] += 1\n        updated_edge_n_used[next_node, current_node] += 1\n    \n    return updated_edge_distance",
          "objective": 0.21234,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm:\nThe new algorithm aims to update the edge distance matrix by considering the local optimal tour and the ratio of the number of times each edge is used to the total number of permutations, but with a different parameter setting of the score function.\n\nUpdated code:\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    # Create a copy of the edge distance and edge used matrices\n    updated_edge_distance = np.copy(edge_distance)\n    updated_edge_n_used = np.copy(edge_n_used)\n    \n    # Get the number of nodes in the tour\n    num_nodes = len(local_opt_tour)\n    total_permutations = num_nodes * (num_nodes - 1)\n    \n    # Iterate over each node in the tour\n    for i in range(num_nodes):\n        # Get the current node ID and the next node ID\n        current_node = local_opt_tour[i]\n        next_node = local_opt_tour[(i + 1) % num_nodes]  # Wrap around to the first node if at the last node\n        \n        # Update the edge distance between the current and next node\n        updated_edge_distance[current_node, next_node] = edge_distance[current_node, next_node] + (1 / (edge_n_used[current_node, next_node] + 1)) * (total_permutations - edge_n_used[current_node, next_node]) / total_permutations\n        \n        # Update the edge distance between the next and current node\n        updated_edge_distance[next_node, current_node] = edge_distance[next_node, current_node] + (1 / (edge_n_used[next_node, current_node] + 1)) * (total_permutations - edge_n_used[next_node, current_node]) / total_permutations\n        \n        # Update the number of times the edge is used\n        updated_edge_n_used[current_node, next_node] += 1\n        updated_edge_n_used[next_node, current_node] += 1\n    \n    return updated_edge_distance",
          "objective": 0.23305,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm description: The new algorithm penalizes the edges used in the local optimal tour based on their number of times used and subtracts a constant multiplied by the logarithm of their current distance value from their distance value, and also adds a constant multiplied by the logarithm of their number of times used, in order to encourage exploration of different routes and prevent being trapped in the local optimum. However, in this new algorithm, the constant_value is set to 10 instead of 5.\n\nNew algorithm code:\n\n```",
          "code": "import numpy as np\nimport math\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n  \n    constant_value = 10  # Constant value to be subtracted/added to the current distance value\n  \n    for i in range(len(local_opt_tour) - 1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n      \n        edge_n_used[edge[0], edge[1]] += 1\n        edge_n_used[edge[1], edge[0]] += 1\n      \n        updated_edge_distance[edge[0], edge[1]] -= constant_value * math.log(edge_distance[edge[0], edge[1]]) * edge_n_used[edge[0], edge[1]] + constant_value * math.log(edge_n_used[edge[0], edge[1]])\n        updated_edge_distance[edge[1], edge[0]] -= constant_value * math.log(edge_distance[edge[1], edge[0]]) * edge_n_used[edge[1], edge[0]] + constant_value * math.log(edge_n_used[edge[1], edge[0]])\n      \n    return updated_edge_distance",
          "objective": 0.24391,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm: The new algorithm aims to update the edge distance matrix by considering the local optimal tour and the ratio of the number of times each edge is used to the total number of permutations, with a higher weight factor for the score function. The new algorithm will use a different weight factor for the score function, defined as a fraction of the maximum edge distance in the matrix.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    # Create a copy of the edge distance and edge used matrices\n    updated_edge_distance = np.copy(edge_distance)\n    updated_edge_n_used = np.copy(edge_n_used)\n    \n    # Get the number of nodes in the tour\n    num_nodes = len(local_opt_tour)\n    total_permutations = num_nodes * (num_nodes - 1)\n    \n    # Set the weight factor for the score function as a fraction of the maximum edge distance\n    weight_factor = 0.5 * np.max(edge_distance)\n    \n    # Iterate over each node in the tour\n    for i in range(num_nodes):\n        # Get the current node ID and the next node ID\n        current_node = local_opt_tour[i]\n        next_node = local_opt_tour[(i + 1) % num_nodes]  # Wrap around to the first node if at the last node\n        \n        # Update the edge distance between the current and next node\n        updated_edge_distance[current_node, next_node] = edge_distance[current_node, next_node] + weight_factor / edge_n_used[current_node, next_node]\n        \n        # Update the edge distance between the next and current node\n        updated_edge_distance[next_node, current_node] = edge_distance[next_node, current_node] + weight_factor / edge_n_used[next_node, current_node]\n        \n        # Update the number of times the edge is used\n        updated_edge_n_used[current_node, next_node] += 1\n        updated_edge_n_used[next_node, current_node] += 1\n    \n    return updated_edge_distance",
          "objective": 0.24574,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm description: The new algorithm updates the edge distance matrix by adding a larger penalty to the edges that are frequently used in the local optimal tour, discouraging the algorithm from using them in future iterations.\n\nCode:\n\n``` ",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    \n    for i in range(len(local_opt_tour)-1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n        edge_n_used[edge] += 1\n        \n    for i in range(len(updated_edge_distance)):\n        for j in range(len(updated_edge_distance)):\n            penalty = edge_n_used[(i, j)] ** 2  # Updated penalty by taking the square of the edge_n_used\n            updated_edge_distance[i][j] += penalty\n    \n    return updated_edge_distance",
          "objective": 0.26474,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm description: The new algorithm penalizes the edges used in the local optimal tour based on their number of times used and subtracts a constant multiplied by the logarithm of their current distance value from their distance value, and also adds a constant multiplied by the logarithm of their number of times used, in order to encourage exploration of different routes and prevent being trapped in the local optimum.\n\nNew algorithm code:\n\n```\n",
          "code": "import numpy as np\nimport math\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n  \n    constant_value = 5  # Constant value to be subtracted/added to the current distance value\n  \n    for i in range(len(local_opt_tour) - 1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n      \n        edge_n_used[edge[0], edge[1]] += 1\n        edge_n_used[edge[1], edge[0]] += 1\n      \n        updated_edge_distance[edge[0], edge[1]] -= constant_value * math.log(edge_distance[edge[0], edge[1]]) * edge_n_used[edge[0], edge[1]] + constant_value * math.log(edge_n_used[edge[0], edge[1]])\n        updated_edge_distance[edge[1], edge[0]] -= constant_value * math.log(edge_distance[edge[1], edge[0]]) * edge_n_used[edge[1], edge[0]] + constant_value * math.log(edge_n_used[edge[1], edge[0]])\n      \n    return updated_edge_distance",
          "objective": 0.26732,
          "other_inf": null
     },
     {
          "algorithm": "New Algorithm Description: The new algorithm updates the edge distance matrix by penalizing the edges used in the local optimal tour based on the squared cumulative inverse distance (1/distance) of each edge in the permutation.\n\nCode:\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n    for i in range(len(local_opt_tour)-1):\n        start_node = local_opt_tour[i]\n        end_node = local_opt_tour[i+1]\n        edge_n_used[start_node][end_node] += (1/edge_distance[start_node][end_node])**2\n        updated_edge_distance[start_node][end_node] += edge_n_used[start_node][end_node]\n        updated_edge_distance[end_node][start_node] += edge_n_used[start_node][end_node]\n    return updated_edge_distance",
          "objective": 0.27005,
          "other_inf": null
     },
     {
          "algorithm": "New Algorithm: The new algorithm penalizes the edges used in the local optimal tour based on their number of times used and adds a constant multiplied by the inverse of their current distance value squared to their distance value in order to encourage exploration of different routes and prevent being trapped in the local optimum.\n\nCode:\n``` ",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n  \n    constant_value = 10  # Constant value to be added to the current distance value\n  \n    for i in range(len(local_opt_tour) - 1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n      \n        edge_n_used[edge[0], edge[1]] += 1\n        edge_n_used[edge[1], edge[0]] += 1\n      \n        updated_edge_distance[edge[0], edge[1]] += constant_value * (1 / (edge_distance[edge[0], edge[1]])**2) * edge_n_used[edge[0], edge[1]]\n        updated_edge_distance[edge[1], edge[0]] += constant_value * (1 / (edge_distance[edge[1], edge[0]])**2) * edge_n_used[edge[1], edge[0]]\n      \n    return updated_edge_distance",
          "objective": 0.27926,
          "other_inf": null
     },
     {
          "algorithm": "New Algorithm Description: The new algorithm updates the edge distance matrix by penalizing the edges used in the local optimal tour based on the squared cumulative distance of each edge in the permutation.\n\nCode:\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n    for i in range(len(local_opt_tour)-1):\n        start_node = local_opt_tour[i]\n        end_node = local_opt_tour[i+1]\n        edge_n_used[start_node][end_node] += edge_distance[start_node][end_node]**2\n        updated_edge_distance[start_node][end_node] += edge_n_used[start_node][end_node]\n        updated_edge_distance[end_node][start_node] += edge_n_used[start_node][end_node]\n    return updated_edge_distance",
          "objective": 0.28727,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm penalizes the edges used in the local optimal tour based on their number of times used and subtracts a constant multiplied by the logarithm of their current distance value from their distance value, and also adds a constant multiplied by the logarithm of their number of times used, in order to encourage exploration of different routes and prevent being trapped in the local optimum.",
          "code": "import numpy as np\r\nimport math\r\n\r\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\r\n    updated_edge_distance = edge_distance.copy()\r\n    \r\n    constant_value = 10  # Constant value to be subtracted/added to the current distance value\r\n    \r\n    for i in range(len(local_opt_tour) - 1):\r\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\r\n        \r\n        edge_n_used[edge[0], edge[1]] += 1\r\n        edge_n_used[edge[1], edge[0]] += 1\r\n        \r\n        # Updated score function\r\n        updated_edge_distance[edge[0], edge[1]] -= constant_value * math.log(edge_distance[edge[0], edge[1]]) * (edge_n_used[edge[0], edge[1]] + 1) + constant_value * math.log(edge_n_used[edge[0], edge[1]])\r\n        updated_edge_distance[edge[1], edge[0]] -= constant_value * math.log(edge_distance[edge[1], edge[0]]) * (edge_n_used[edge[1], edge[0]] + 1) + constant_value * math.log(edge_n_used[edge[1], edge[0]])\r\n    \r\n    return updated_edge_distance",
          "objective": 0.28993,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm description: The new algorithm penalizes the edges used in the local optimal tour based on their number of times used and adds a constant multiplied by the inverse of their current distance value to their distance value in order to encourage exploration of different routes and prevent being trapped in the local optimum.\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n  \n    constant_value = 10  # Constant value to be added to the current distance value\n  \n    for i in range(len(local_opt_tour) - 1):\n        edge = (local_opt_tour[i], local_opt_tour[i+1])\n      \n        edge_n_used[edge[0], edge[1]] += 1\n        edge_n_used[edge[1], edge[0]] += 1\n      \n        updated_edge_distance[edge[0], edge[1]] += constant_value * (1 / edge_distance[edge[0], edge[1]]) * edge_n_used[edge[0], edge[1]]\n        updated_edge_distance[edge[1], edge[0]] += constant_value * (1 / edge_distance[edge[1], edge[0]]) * edge_n_used[edge[1], edge[0]]\n      \n    return updated_edge_distance",
          "objective": 0.29682,
          "other_inf": null
     }
]