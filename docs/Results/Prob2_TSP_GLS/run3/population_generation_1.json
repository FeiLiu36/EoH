[
     {
          "algorithm": "New Algorithm Description: The new algorithm updates the edge distance matrix by adding a penalty to the distances of edges that have been frequently used in the local optimal tour, with a penalty factor increased by a higher power of the difference between the maximum number of edge uses and the actual number of edge uses.\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    max_n_used = np.max(edge_n_used)\n    penalty_factor = 0.1 * np.power((max_n_used - edge_n_used), 2)\n    \n    for i in range(len(local_opt_tour)-1):\n        edge_i = local_opt_tour[i]\n        edge_j = local_opt_tour[i+1]\n        \n        updated_edge_distance[edge_i][edge_j] += penalty_factor[edge_i][edge_j]\n        updated_edge_distance[edge_j][edge_i] = updated_edge_distance[edge_i][edge_j] # symmetrical matrix\n        \n    return updated_edge_distance",
          "objective": 0.02561,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm description: The new algorithm updates the edge distance matrix by adding a penalty to the distances of edges that have been frequently used in the local optimal tour based on a linearly decreasing function of the number of times each edge has been used.\n\nCode:\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    max_n_used = np.max(edge_n_used)\n    \n    for i in range(len(local_opt_tour)-1):\n        edge_i = local_opt_tour[i]\n        edge_j = local_opt_tour[i+1]\n        \n        penalty = (max_n_used - edge_n_used[edge_i][edge_j]) * 0.05 # new parameter setting\n        \n        updated_edge_distance[edge_i][edge_j] += penalty\n        updated_edge_distance[edge_j][edge_i] = updated_edge_distance[edge_i][edge_j] # symmetrical matrix\n        \n    return updated_edge_distance",
          "objective": 0.03499,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm description: The new algorithm updates the edge distance matrix by adding a penalty to the distances of edges that have been frequently used in the local optimal tour based on a logarithmically decreasing function of the number of times each edge has been used.\n\nCode:\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    max_n_used = np.max(edge_n_used)\n    \n    for i in range(len(local_opt_tour)-1):\n        edge_i = local_opt_tour[i]\n        edge_j = local_opt_tour[i+1]\n        \n        penalty = np.log(max_n_used + 1) / (edge_n_used[edge_i][edge_j] + 1)\n        \n        updated_edge_distance[edge_i][edge_j] += penalty\n        updated_edge_distance[edge_j][edge_i] = updated_edge_distance[edge_i][edge_j] # symmetrical matrix\n        \n    return updated_edge_distance",
          "objective": 0.03641,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm updates the edge distance matrix by adding a penalty to the distances of edges that have been frequently used in the local optimal tour.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    max_n_used = np.max(edge_n_used)\n    \n    for i in range(len(local_opt_tour)-1):\n        edge_i = local_opt_tour[i]\n        edge_j = local_opt_tour[i+1]\n        \n        updated_edge_distance[edge_i][edge_j] += 0.1 * (max_n_used - edge_n_used[edge_i][edge_j])\n        updated_edge_distance[edge_j][edge_i] = updated_edge_distance[edge_i][edge_j] # symmetrical matrix\n        \n    return updated_edge_distance",
          "objective": 0.04671,
          "other_inf": null
     },
     {
          "algorithm": "New Algorithm: The new algorithm updates the edge distance matrix based on the local optimal tour by redistributing the edge distances to decrease the distance for edges used more frequently in the tour and increase the distance for edges used less frequently with a modified score function that includes a weight factor for the edge usage and a decay factor. The weight factor and decay factor are set to 4 and 0.9 respectively.\n\nPython code:\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n    total_distance = np.sum(updated_edge_distance)\n\n    for i in range(len(local_opt_tour)-1):\n        edge_index = local_opt_tour[i], local_opt_tour[i+1]\n\n        current_distance = updated_edge_distance[edge_index]\n        current_usage = edge_n_used[edge_index]\n\n        weight_factor = 4  # Define a different weight factor for edge usage\n        decay_factor = 0.9  # Define a different decay factor for distance modification\n\n        updated_distance = current_distance - ((current_distance - total_distance / current_usage) / (current_usage * weight_factor)) * decay_factor\n\n        updated_edge_distance[edge_index] = updated_distance\n\n    return updated_edge_distance",
          "objective": 0.05397,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm:\nThe new algorithm updates the edge distance matrix based on the local optimal tour by redistributing the edge distances to decrease the distance for edges used more frequently in the tour and increase the distance for edges used less frequently, while ensuring that the total distance remains the same.\n\nPython code:\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n\n    total_distance = np.sum(updated_edge_distance)\n\n    for i in range(len(local_opt_tour)-1):\n        edge_index = local_opt_tour[i], local_opt_tour[i+1]\n\n        current_distance = updated_edge_distance[edge_index]\n        current_usage = edge_n_used[edge_index]\n\n        updated_distance = current_distance - (current_distance - total_distance / current_usage) / current_usage\n\n        updated_edge_distance[edge_index] = updated_distance\n\n    return updated_edge_distance",
          "objective": 0.07823,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm: The new algorithm updates the edge distance matrix based on the local optimal tour by redistributing the edge distances to decrease the distance for edges used more frequently in the tour and increase the distance for edges used less frequently with a modified score function that includes a weight factor for the edge usage and a decay factor (with different parameter values).\n\nPython code:\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n    total_distance = np.sum(updated_edge_distance)\n\n    for i in range(len(local_opt_tour)-1):\n        edge_index = local_opt_tour[i], local_opt_tour[i+1]\n\n        current_distance = updated_edge_distance[edge_index]\n        current_usage = edge_n_used[edge_index]\n\n        weight_factor = 3  # Define a different weight factor for edge usage\n        decay_factor = 0.8  # Define a different decay factor for distance modification\n\n        updated_distance = current_distance - ((current_distance - total_distance / current_usage) / (current_usage * weight_factor)) * decay_factor\n\n        updated_edge_distance[edge_index] = updated_distance\n\n    return updated_edge_distance",
          "objective": 0.08591,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm: The new algorithm updates the edge distance matrix based on the local optimal tour by redistributing the edge distances to decrease the distance for edges used more frequently in the tour and increase the distance for edges used less frequently with a modified score function that includes a weight factor for the edge usage and a decay factor.\n\nPython code:\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n    total_distance = np.sum(updated_edge_distance)\n\n    for i in range(len(local_opt_tour)-1):\n        edge_index = local_opt_tour[i], local_opt_tour[i+1]\n\n        current_distance = updated_edge_distance[edge_index]\n        current_usage = edge_n_used[edge_index]\n\n        weight_factor = 2  # Define a weight factor for edge usage\n        decay_factor = 0.5  # Define a decay factor for distance modification\n\n        updated_distance = current_distance - ((current_distance - total_distance / current_usage) / (current_usage * weight_factor)) * decay_factor\n\n        updated_edge_distance[edge_index] = updated_distance\n\n    return updated_edge_distance",
          "objective": 0.08733,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm updates the edge distance matrix based on the local optimal tour by redistributing the edge distances to decrease the distance for edges used more frequently in the tour and increase the distance for edges used less frequently, while ensuring that the total distance remains the same. The updated edge distances are calculated using a weighted average of the current distance and the total distance divided by the usage count, with a different score function that includes a penalty term based on the square root of the current usage count.",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n\n    total_distance = np.sum(updated_edge_distance)\n\n    for i in range(len(local_opt_tour)-1):\n        edge_index = local_opt_tour[i], local_opt_tour[i+1]\n\n        current_distance = updated_edge_distance[edge_index]\n        current_usage = edge_n_used[edge_index]\n\n        # Updated score function with penalty term\n        updated_distance = current_distance - (current_distance - total_distance / (current_usage + 1) - np.sqrt(current_usage)) / (current_usage + 1)\n\n        updated_edge_distance[edge_index] = updated_distance\n\n    return updated_edge_distance",
          "objective": 0.08807,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm:\nThe new algorithm updates the edge distance matrix based on the local optimal tour and the number of times each edge is used, by increasing the distance for edges used more frequently and decreasing the distance for edges used less frequently, while keeping the total distance constant.\n\nPython code:\n\n```\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n\n    total_distance = np.sum(updated_edge_distance)\n\n    for i in range(len(local_opt_tour)-1):\n        edge_index = local_opt_tour[i], local_opt_tour[i+1]\n\n        current_distance = updated_edge_distance[edge_index]\n        current_usage = edge_n_used[edge_index]\n\n        updated_distance = current_distance + (total_distance - current_distance) / (current_usage + 1)\n\n        updated_edge_distance[edge_index] = updated_distance\n\n    return updated_edge_distance",
          "objective": 0.09316,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm updates the edge distance matrix based on the local optimal tour by redistributing the edge distances to decrease the distance for edges used more frequently in the tour and increase the distance for edges used less frequently, while ensuring that the total distance remains the same. The updated edge distances are calculated using a modified score function that takes into account the current distance, total distance, and usage count. \n\n",
          "code": "def update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n    total_distance = np.sum(updated_edge_distance)\n\n    for i in range(len(local_opt_tour)-1):\n        edge_index = local_opt_tour[i], local_opt_tour[i+1]\n        current_distance = updated_edge_distance[edge_index]\n        current_usage = edge_n_used[edge_index]\n\n        # New score function\n        updated_distance = current_distance - (current_distance - (total_distance / (current_usage + 1))) / ((current_usage + 1) ** 0.5)\n\n        updated_edge_distance[edge_index] = updated_distance\n\n    return updated_edge_distance",
          "objective": 0.09369,
          "other_inf": null
     },
     {
          "algorithm": "New Algorithm: The new algorithm updates the edge distance matrix by increasing the distances of the edges that belong to the local optimal tour and have not been used before, while decreasing the distances of the edges that were not used in the tour based on the number of times each edge was used during permutation. The scoring function is modified to weight the increase and decrease of the distances differently, with a higher weight assigned to the decrease of unused edges. Additionally, the weight for decreasing the distances of unused edges is increased to 0.9 to prioritize minimizing the distance.\n\nImplementation:\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    used_edges = np.zeros(edge_distance.shape)\n\n    # Step 1: Update distances of edges belonging to the local optimal tour\n    for i in range(len(local_opt_tour)-1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i+1]\n\n        if used_edges[start][end] == 0:\n            updated_edge_distance[start][end] += 1\n        else:\n            updated_edge_distance[start][end] -= 1\n\n        if used_edges[end][start] == 0:\n            updated_edge_distance[end][start] += 1\n        else:\n            updated_edge_distance[end][start] -= 1\n\n    # Step 2: Update distances of edges not used in the tour\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if used_edges[i][j] > 0:\n                updated_edge_distance[i][j] += used_edges[i][j] * 0.5  # Increase distance with weight 0.5\n            else:\n                updated_edge_distance[i][j] -= edge_n_used[i][j] * 0.9  # Decrease distance with weight 0.9\n\n    return updated_edge_distance",
          "objective": 0.09401,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm:\nThe new algorithm updates the edge distance matrix based on the local optimal tour by redistributing the edge distances to decrease the distance for edges used more frequently in the tour and increase the distance for edges used less frequently, while ensuring that the total distance remains the same. The updated edge distances are calculated using a weighted average of the current distance and the total distance divided by the usage count, with a different score function.\n\nPython code:\n\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n\n    total_distance = np.sum(updated_edge_distance)\n\n    for i in range(len(local_opt_tour)-1):\n        edge_index = local_opt_tour[i], local_opt_tour[i+1]\n\n        current_distance = updated_edge_distance[edge_index]\n        current_usage = edge_n_used[edge_index]\n\n        # Updated score function\n        updated_distance = current_distance - (current_distance - total_distance / (current_usage + 1)) / (current_usage + 1)\n\n        updated_edge_distance[edge_index] = updated_distance\n\n    return updated_edge_distance",
          "objective": 0.09457,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm: The new algorithm updates the edge distance matrix based on the local optimal tour by redistributing the edge distances to decrease the distance for edges used more frequently in the tour and increase the distance for edges used less frequently with a modified score function that includes a weight factor for the edge usage.\n\nPython code:\n\n```\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n    total_distance = np.sum(updated_edge_distance)\n\n    for i in range(len(local_opt_tour)-1):\n        edge_index = local_opt_tour[i], local_opt_tour[i+1]\n\n        current_distance = updated_edge_distance[edge_index]\n        current_usage = edge_n_used[edge_index]\n\n        weight_factor = 2  # Define a weight factor for edge usage\n\n        updated_distance = current_distance - (current_distance - total_distance / current_usage) / (current_usage * weight_factor)\n\n        updated_edge_distance[edge_index] = updated_distance\n\n    return updated_edge_distance",
          "objective": 0.10489,
          "other_inf": null
     },
     {
          "algorithm": "New Algorithm: The new algorithm updates the edge distance matrix by increasing the distances of the edges that belong to the local optimal tour and have not been used before, while decreasing the distances of the edges that were not used in the tour based on the number of times each edge was used during permutation. The scoring function is modified to weight the increase and decrease of the distances differently, with a higher weight assigned to the decrease of unused edges.\n\nImplementation:\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    used_edges = np.zeros(edge_distance.shape)\n\n    # Step 1: Update distances of edges belonging to the local optimal tour\n    for i in range(len(local_opt_tour)-1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i+1]\n\n        if used_edges[start][end] == 0:\n            updated_edge_distance[start][end] += 1\n        else:\n            updated_edge_distance[start][end] -= 1\n\n        if used_edges[end][start] == 0:\n            updated_edge_distance[end][start] += 1\n        else:\n            updated_edge_distance[end][start] -= 1\n\n    # Step 2: Update distances of edges not used in the tour\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if used_edges[i][j] > 0:\n                updated_edge_distance[i][j] += used_edges[i][j] * 0.5  # Increase distance with weight 0.5\n            else:\n                updated_edge_distance[i][j] -= edge_n_used[i][j] * 0.8  # Decrease distance with weight 0.8\n\n    return updated_edge_distance",
          "objective": 0.11147,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm: \"The new algorithm updates the edge distance matrix based on the local optimal tour by redistributing the edge distances to decrease the distance for edges used more frequently in the tour and increase the distance for edges used less frequently, while ensuring that the total distance remains the same. The updated edge distances are calculated using a weighted average of the current distance and the total distance divided by the usage count, with a different score function that includes a penalty term based on the square of the current usage count.\"\n\nPython code:\n\n``` ",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = edge_distance.copy()\n\n    total_distance = np.sum(updated_edge_distance)\n\n    for i in range(len(local_opt_tour)-1):\n        edge_index = local_opt_tour[i], local_opt_tour[i+1]\n\n        current_distance = updated_edge_distance[edge_index]\n        current_usage = edge_n_used[edge_index]\n\n        # Updated score function with penalty term\n        updated_distance = current_distance - (current_distance - total_distance / (current_usage + 1) - current_usage**2) / (current_usage + 1)\n\n        updated_edge_distance[edge_index] = updated_distance\n\n    return updated_edge_distance",
          "objective": 0.11221,
          "other_inf": null
     },
     {
          "algorithm": "New Algorithm: The new algorithm updates the edge distance matrix by increasing the distances of the edges that belong to the local optimal tour and have not been used before, while decreasing the distances of the edges that were not used in the tour based on a weighted factor calculated by multiplying the number of times each edge was used during permutation with a constant weight factor.\n\nCode:\n",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    used_edges = np.zeros(edge_distance.shape)\n    weight_factor = 0.5  # Constant weight factor used to calculate weighted scores\n    \n    for i in range(len(local_opt_tour)-1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i+1]\n        \n        if used_edges[start][end] == 0:\n            updated_edge_distance[start][end] += 1\n        else:\n            updated_edge_distance[start][end] -= 1\n        \n        if used_edges[end][start] == 0:\n            updated_edge_distance[end][start] += 1\n        else:\n            updated_edge_distance[end][start] -= 1\n    \n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if used_edges[i][j] > 0:\n                updated_edge_distance[i][j] += used_edges[i][j]\n            else:\n                updated_edge_distance[i][j] -= edge_n_used[i][j] * weight_factor\n    \n    return updated_edge_distance",
          "objective": 0.13206,
          "other_inf": null
     },
     {
          "algorithm": "New Algorithm: The new algorithm updates the edge distance matrix by increasing the distances of the edges that belong to the local optimal tour and have not been used before, while decreasing the distances of the edges that were not used in the tour based on the number of times each edge was used during permutation. The scoring function is modified to weight the increase and decrease of the distances differently, with a higher weight assigned to the decrease of unused edges and a lower weight assigned to the increase of used edges.\n\nImplementation:\n\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    used_edges = np.zeros(edge_distance.shape)\n\n    # Step 1: Update distances of edges belonging to the local optimal tour\n    for i in range(len(local_opt_tour)-1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i+1]\n\n        if used_edges[start][end] == 0:\n            updated_edge_distance[start][end] += 0.5  # Increase distance with weight 0.5\n        else:\n            updated_edge_distance[start][end] -= 0.8  # Decrease distance with weight 0.8\n\n        if used_edges[end][start] == 0:\n            updated_edge_distance[end][start] += 0.5  # Increase distance with weight 0.5\n        else:\n            updated_edge_distance[end][start] -= 0.8  # Decrease distance with weight 0.8\n\n    # Step 2: Update distances of edges not used in the tour\n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if used_edges[i][j] > 0:\n                updated_edge_distance[i][j] += used_edges[i][j] * 0.3  # Increase distance with weight 0.3\n            else:\n                updated_edge_distance[i][j] -= edge_n_used[i][j] * 0.5  # Decrease distance with weight 0.5\n\n    return updated_edge_distance",
          "objective": 0.15666,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm updates the edge distance matrix by increasing the distances of the edges that belong to the local optimal tour and have not been used before, while decreasing the distances of the edges that were not used in the tour based on the number of times each edge was used during permutation.",
          "code": "def update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    used_edges = np.zeros(edge_distance.shape)\n    \n    for i in range(len(local_opt_tour)-1):\n        start = local_opt_tour[i]\n        end = local_opt_tour[i+1]\n        \n        if used_edges[start][end] == 0:\n            updated_edge_distance[start][end] += 1\n        else:\n            updated_edge_distance[start][end] -= 1\n        \n        if used_edges[end][start] == 0:\n            updated_edge_distance[end][start] += 1\n        else:\n            updated_edge_distance[end][start] -= 1\n    \n    for i in range(edge_distance.shape[0]):\n        for j in range(edge_distance.shape[1]):\n            if used_edges[i][j] > 0:\n                updated_edge_distance[i][j] += used_edges[i][j]\n            else:\n                updated_edge_distance[i][j] -= edge_n_used[i][j]\n    \n    return updated_edge_distance",
          "objective": 0.172,
          "other_inf": null
     },
     {
          "algorithm": "New Algorithm Description: The algorithm updates the edge distance matrix by increasing the distance of edges that were less frequently used in the local optimal tour, with the amount of increase being proportional to the square root of the inverse of the number of times the edge was used.\n\nCode:\n```",
          "code": "import numpy as np\n\ndef update_edge_distance(edge_distance, local_opt_tour, edge_n_used):\n    updated_edge_distance = np.copy(edge_distance)\n    for i in range(len(local_opt_tour)-1):\n        edge_id = local_opt_tour[i], local_opt_tour[i+1]\n        updated_edge_distance[edge_id] += np.sqrt(1 / (1 + edge_n_used[edge_id]))\n    return updated_edge_distance",
          "objective": 0.22205,
          "other_inf": null
     }
]