[
     {
          "algorithm": "The \"Maximum Score with Item Size Penalty and Rest Capacity Bonus\" algorithm assigns an item to the bin with the maximum score and updates the rest capacity of the bin accordingly, until all items are assigned. The score for each bin is calculated as the bin's current capacity divided by the difference between the bin's capacity and the item size, minus the number of times the bin has been used, plus the bin's rest capacity.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    scores = bins / (bins - item) - np.arange(len(bins)) + bins\n    return scores",
          "objective": 0.0166,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm: \"Item Size-Based Score with Rest Capacity Bonus, Distance Penalty, and Bin Utilization\"",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Add a term to encourage the use of bins with lower utilization levels\n    utilization_levels = np.divide(bins, bins.max())\n    scores += np.log(utilization_levels)\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.02908,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm: \"Item Size-Based Score with Rest Capacity Bonus, Distance Penalty, and Bin Utilization Factor with Exponential Decay and Randomness\"",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Add an exponential decay factor to the distance penalty term\n    decay_factor = 0.5\n    scores -= decay_factor * np.exp(-distances / (decay_factor * bins.max()))\n    \n    # Add a randomness factor to the score\n    randomness_factor = 0.1\n    scores += randomness_factor * np.random.rand(len(bins))\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.02958,
          "other_inf": null
     },
     {
          "algorithm": " New algorithm: \"Item Size-Based Score with Rest Capacity Bonus and Distance Penalty with Exponential Decay\"\n\nThis algorithm assigns an item to the bin with the highest score, which is calculated based on the item size, the rest capacity of the bin, and the distance between the item size and the bin capacity, with an exponential decay factor applied to the distance penalty. The score is higher when the item size is closer to the bin capacity and the rest capacity of the bin is higher, and the distance penalty decreases exponentially as the distance increases.\n\nImplementation:\n```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Apply an exponential decay factor to the distance penalty\n    decay_factor = 0.5\n    scores -= decay_factor * np.exp(-distances / (item + 1))\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.02978,
          "other_inf": null
     },
     {
          "algorithm": " Common backbone idea: The provided algorithms use various methods to calculate the score of each bin based on the item size, the rest capacity of the bin, and other factors.\n\nNew algorithm: \"Item Size-Based Score with Rest Capacity Bonus and Distance Penalty with Exponential Decay and Item Size-Bin Capacity Ratio\"\n\nThis algorithm assigns an item to the bin with the highest score, which is calculated based on the item size, the rest capacity of the bin, the distance between the item size and the bin capacity, and the ratio of the item size to the bin capacity. The score is higher when the item size is closer to the bin capacity, the rest capacity of the bin is higher, and the ratio of the item size to the bin capacity is lower.\n\nImplementation:\n```\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Add a robust distance metric\n    distances = np.maximum(distances, 1e-6)\n    \n    # Modify the score formula to include more features\n    scores += np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Add a penalty term for bins that are close to being full\n    penalty = np.exp(-(bins / bins.max()) ** 2)\n    scores -= penalty\n    \n    # Add a bonus term for bins that have a large rest capacity\n    bonus = np.exp((bins.max() - bins) / bins.max())\n    scores += bonus\n    \n    # Add a term to penalize bins with a high item size-bin capacity ratio\n    ratio = item / bins\n    scores -= np.log(ratio)\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.02988,
          "other_inf": null
     },
     {
          "algorithm": " New algorithm: \"Item Size-Based Score with Rest Capacity Bonus and Distance Penalty with Exponential Decay\"\n\nIn this algorithm, we modify the previous algorithm by adding an exponential decay factor to the distance penalty term. This factor reduces the impact of the distance penalty as the distance between the item size and the bin capacity increases.\n\nImplementation:\n```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Add an exponential decay factor to the distance penalty term\n    decay_factor = 0.5\n    scores -= decay_factor * np.exp(-distances / (decay_factor * bins.max()))\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.03008,
          "other_inf": null
     },
     {
          "algorithm": " New algorithm: \"Item Size-Based Score with Rest Capacity Bonus and Distance Penalty with Exponential Decay\"\n\nIn this algorithm, we modify the previous algorithm by adding an exponential decay factor to the distance penalty term. This factor reduces the impact of the distance penalty as the distance between the item size and the bin capacity increases.\n\nImplementation:\n```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Add a robust distance metric\n    distances = np.maximum(distances, 1e-6)\n    \n    # Modify the score formula to include more features\n    scores += np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Choose the decay factor based on cross-validation\n    decay_factor = 0.5\n    scores -= decay_factor * np.exp(-distances / (decay_factor * bins.max()))\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.03018,
          "other_inf": null
     },
     {
          "algorithm": " Common backbone idea: The provided algorithms use various methods to calculate the score of each bin based on the item size, the rest capacity of the bin, and other factors.\n\nNew algorithm: \"Item Size-Based Score with Rest Capacity Bonus and Distance Penalty with Exponential Decay and Randomness\"\n\nIn this algorithm, we modify the previous algorithm by adding an exponential decay factor to the distance penalty term and introducing randomness to the score calculation. The exponential decay factor reduces the impact of the distance penalty as the distance between the item size and the bin capacity increases, while the randomness adds a layer of uncertainty to the score calculation, making it more difficult for the algorithm to converge to a single optimal solution.\n\nImplementation:\n```\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Add an exponential decay factor to the distance penalty term\n    decay_factor = 0.5\n    scores -= decay_factor * np.exp(-distances / (decay_factor * bins.max()))\n    \n    # Introduce randomness to the score calculation\n    random_factor = 0.1\n    scores += random_factor * np.random.rand(len(bins))\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.03028,
          "other_inf": null
     },
     {
          "algorithm": " Common backbone idea: The provided algorithms use various methods to calculate the score of each bin based on the item size, the rest capacity of the bin, and other factors.\n\nNew algorithm: \"Item Size-Based Score with Rest Capacity Bonus and Distance Penalty\"\nThis algorithm assigns an item to the bin with the highest score, which is calculated based on the item size, the rest capacity of the bin, and the distance between the item size and the bin capacity. The score is higher when the item size is closer to the bin capacity and the rest capacity of the bin is higher.\n\nImplementation:\n```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.03049,
          "other_inf": null
     },
     {
          "algorithm": " Common backbone idea: The provided algorithms use a combination of the item size, the rest capacity of each bin, and the distance between the item size and the maximum capacity of the bins to calculate the score.\n\nNew algorithm: \"Item Size-Based Score with Rest Capacity Bonus, Distance Penalty, and Bin Utilization Factor with Exponential Decay\"\n\nDescription: This algorithm assigns an item to the bin with the highest score, which is calculated based on the item size, the rest capacity of the bin, the distance between the item size and the bin capacity, and the number of times the bin has been used, with an exponential decay factor applied to the distance penalty and the bin utilization factor. The score is higher when the item size is closer to the bin capacity, the rest capacity of the bin is higher, the distance between the item size and the bin capacity is smaller, and the bin has been used fewer times.\n\nImplementation:\n```\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Apply an exponential decay factor to the distance penalty\n    decay_factor = 0.5\n    scores -= decay_factor * np.exp(-distances / (item + 1))\n    \n    # Apply an exponential decay factor to the bin utilization factor\n    utilization_factor = 0.5\n    scores -= utilization_factor * np.exp(-np.arange(len(bins)))\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.03109,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm: \"Item Size-Based Score with Rest Capacity Bonus, Distance Penalty, and Bin Utilization Factor\"",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Add a bin utilization factor to the score calculation\n    utilization_factor = 0.5\n    scores += utilization_factor * (1 - (bins / bins.max()))\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.03119,
          "other_inf": null
     },
     {
          "algorithm": " Common backbone idea: The provided algorithms use various combinations of item size, bin capacity, and distance metrics to calculate scores for assigning an item to a bin.\n\nNew algorithm: \"Item Size-Based Score with Rest Capacity Bonus, Distance Penalty, and Bin Utilization Factor with Exponential Decay and Self-Adaptive Learning Rate\"\n\nDescription: This algorithm assigns an item to the bin with the highest score, which is calculated based on the item size, the rest capacity of the bin, the distance between the item size and the bin capacity, the number of times the bin has been used, and the total capacity of all bins, with an exponentially decaying learning rate and a self-adaptive learning rate. The score is higher when the item size is closer to the bin capacity, the rest capacity of the bin is higher, the distance between the item size and the bin capacity is smaller, the bin has been used fewer times, and the total capacity of all bins is higher.\n\nImplementation:\n```\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Add a bonus term for bins that are far from being full\n    bonus = np.exp((bins / bins.max()) ** 2)\n    scores += bonus\n    \n    # Add a penalty term for bins that are close to being full\n    penalty = np.exp(-(bins / bins.max()) ** 2)\n    scores -= penalty\n    \n    # Choose the decay factor based on cross-validation\n    decay_factor = 0.5\n    scores -= decay_factor * np.exp(-distances / (decay_factor * bins.max()))\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    # Calculate the self-adaptive learning rate\n    learning_rate = np.minimum(np.exp(-item / (10 * bins.max())), 0.5)\n    \n    # Update the scores based on the self-adaptive learning rate\n    scores = scores * (1 - learning_rate) + learning_rate * np.random.uniform(0, 1, len(bins))\n    \n    return scores",
          "objective": 0.03129,
          "other_inf": null
     },
     {
          "algorithm": "The \"Maximum Score with Item Size Penalty and Rest Capacity Bonus\" algorithm assigns an item to the bin with the maximum score and updates the rest capacity of the bin accordingly, until all items are assigned. The score for each bin is calculated as the bin's current capacity divided by the difference between the bin's capacity and the item size, minus the number of times the bin has been used, plus the bin's rest capacity.",
          "code": "import numpy as np\n\ndef score_log(item, bins):\n    scores = np.log(bins / (bins - item)) - np.arange(len(bins)) + bins\n    return scores",
          "objective": 0.03139,
          "other_inf": null
     },
     {
          "algorithm": " Common backbone idea: The provided algorithms use various combinations of item size, bin capacity, and distance metrics to calculate scores for assigning an item to a bin.\n\nNew algorithm: \"Item Size-Based Score with Rest Capacity Bonus and Distance Penalty with Exponential Decay and Self-Adaptive Learning Rate\"\n\nDescription: This algorithm modifies the previous algorithm by incorporating an exponentially decaying learning rate to adapt the distance penalty based on the item size and the bin capacity. Additionally, the algorithm includes a self-adaptive learning rate that adjusts the weight of the distance penalty based on the item size and the bin capacity.\n\nImplementation:\n```\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Add a robust distance metric\n    distances = np.maximum(distances, 1e-6)\n    \n    # Modify the score formula to include more features\n    scores += np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Choose the decay factor based on cross-validation\n    decay_factor = 0.5\n    scores -= decay_factor * np.exp(-distances / (decay_factor * bins.max()))\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    # Calculate the self-adaptive learning rate\n    learning_rate = np.minimum(np.exp(-item / (10 * bins.max())), 0.5)\n    \n    # Update the scores based on the self-adaptive learning rate\n    scores = scores * (1 - learning_rate) + learning_rate * np.random.uniform(0, 1, len(bins))\n    \n    return scores",
          "objective": 0.03189,
          "other_inf": null
     },
     {
          "algorithm": " New algorithm: \"Item Size-Based Score with Rest Capacity Bonus and Distance Penalty with Linear Decay and Self-Consistency\"\n\nIn this algorithm, we modify the previous algorithm by replacing the exponential decay factor with a linear decay factor and removing the randomness component. The linear decay factor reduces the impact of the distance penalty as the distance between the item size and the bin capacity increases, while the self-consistency ensures that the score calculation is consistent across all bins.\n\nImplementation:\n```\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Add a linear decay factor to the distance penalty term\n    decay_factor = 0.5\n    scores -= decay_factor * np.minimum(distances / (decay_factor * bins.max()), 1)\n    \n    # Ensure self-consistency by normalizing the scores\n    scores /= np.sum(scores)\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.032,
          "other_inf": null
     },
     {
          "algorithm": " My new algorithm is called \"Item Size-Based Score with Rest Capacity Bonus, Distance Penalty, and Linear Decay\". It modifies the previous algorithm by replacing the exponential decay factor with a linear decay factor. This factor reduces the impact of the distance penalty as the distance between the item size and the bin capacity increases.\n\nHere is the implementation of the new algorithm in Python:\n```\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Add a linear decay factor to the distance penalty term\n    decay_factor = 0.5\n    scores -= decay_factor * (distances / (decay_factor * bins.max()))\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.0321,
          "other_inf": null
     },
     {
          "algorithm": " New algorithm: \"Novel Score Function\"\n\nThis algorithm uses a different parameter setting for the score function, where the bonus term is based on the inverse of the bin's capacity instead of the square of the ratio of the bin's capacity to the maximum capacity.\n\nPython implementation:\n```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item's size and the bin's capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item's size, the distance, and the number of items already placed in the bin\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(np.sum(bins)) - np.log(bins)\n    \n    # Add a bonus term for bins that are far from being full\n    bonus = np.exp(-(bins / bins.max()))\n    scores += bonus\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.0325,
          "other_inf": null
     },
     {
          "algorithm": " New algorithm: \"Item Size-Based Score with Rest Capacity Bonus and Distance Penalty with Exponential Decay and Self-Consistency\"\n\nIn this algorithm, we modify the previous algorithm by adding a self-consistency term to the score calculation. The self-consistency term ensures that the score of a bin is consistent across all items, which helps to prevent the algorithm from getting stuck in local optima.\n\nImplementation:\n```\n",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Add an exponential decay factor to the distance penalty term\n    decay_factor = 0.5\n    scores -= decay_factor * np.exp(-distances / (decay_factor * bins.max()))\n    \n    # Introduce self-consistency to the score calculation\n    consistency_factor = 0.1\n    scores += consistency_factor * np.mean(np.abs(scores - np.mean(scores)))\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.0328,
          "other_inf": null
     },
     {
          "algorithm": "A new algorithm that considers the item size, the distance between the item size and the bin capacity, the number of items already placed in the bin, and the total capacity of all bins to calculate the score.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the distance, and the number of items already placed in the bin\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(np.sum(bins)) - np.log(bins)\n    \n    # Add a penalty term for bins that are close to being full\n    penalty = np.exp(-(bins / bins.max()) ** 2)\n    scores -= penalty\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    return scores",
          "objective": 0.0329,
          "other_inf": null
     },
     {
          "algorithm": "New algorithm: \"Item Size-Based Score with Rest Capacity Bonus, Distance Penalty, and Bin Utilization Factor with Exponential Decay\"",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the distance between the item size and the bin capacity\n    distances = np.abs(bins - item)\n    \n    # Calculate the score based on the item size, the rest capacity of the bin, and the distance\n    scores = np.log(item / distances) + np.sqrt(distances) + np.log(bins) - np.log(bins - item + 1)\n    \n    # Adjust the score based on the total capacity of all bins\n    total_capacity = np.sum(bins)\n    scores += np.log(total_capacity) - np.log(bins)\n    \n    # Set the score to zero if the bin's capacity is equal to the maximum capacity\n    scores[bins == bins.max()] = 0\n    \n    # Apply an exponential decay factor to the score\n    decay_factor = 0.5\n    scores -= decay_factor * np.exp(-distances / (item + 1))\n    \n    return scores",
          "objective": 0.0332,
          "other_inf": null
     }
]